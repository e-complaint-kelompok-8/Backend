
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">capstone/config/config.go (0.0%)</option>
				
				<option value="file1">capstone/config/migration.go (0.0%)</option>
				
				<option value="file2">capstone/controllers/auth/auth_controller.go (0.0%)</option>
				
				<option value="file3">capstone/controllers/auth/auth_controller_admin.go (0.0%)</option>
				
				<option value="file4">capstone/controllers/auth/request/login.go (0.0%)</option>
				
				<option value="file5">capstone/controllers/auth/request/login_admin.go (0.0%)</option>
				
				<option value="file6">capstone/controllers/auth/request/register.go (0.0%)</option>
				
				<option value="file7">capstone/controllers/auth/request/register_admin.go (0.0%)</option>
				
				<option value="file8">capstone/controllers/auth/response/admin_profile.go (0.0%)</option>
				
				<option value="file9">capstone/controllers/auth/response/login.go (0.0%)</option>
				
				<option value="file10">capstone/controllers/auth/response/login_admin.go (0.0%)</option>
				
				<option value="file11">capstone/controllers/auth/response/register.go (0.0%)</option>
				
				<option value="file12">capstone/controllers/auth/response/register_admin.go (0.0%)</option>
				
				<option value="file13">capstone/controllers/auth/response/user_profile.go (0.0%)</option>
				
				<option value="file14">capstone/controllers/category/category_controllers.go (0.0%)</option>
				
				<option value="file15">capstone/controllers/category/request/category.go (0.0%)</option>
				
				<option value="file16">capstone/controllers/category/response/category.go (0.0%)</option>
				
				<option value="file17">capstone/controllers/comment/request/comment.go (0.0%)</option>
				
				<option value="file18">capstone/controllers/comment/response/comment.go (0.0%)</option>
				
				<option value="file19">capstone/controllers/comment/user_comment.go (0.0%)</option>
				
				<option value="file20">capstone/controllers/complaints/complaints_controller.go (0.0%)</option>
				
				<option value="file21">capstone/controllers/complaints/manage_complaints_controller.go (0.0%)</option>
				
				<option value="file22">capstone/controllers/complaints/request/complaint_req.go (0.0%)</option>
				
				<option value="file23">capstone/controllers/complaints/response/complaint_res.go (0.0%)</option>
				
				<option value="file24">capstone/controllers/customer_service/customer_service_controller.go (0.0%)</option>
				
				<option value="file25">capstone/controllers/customer_service/response/customer_service_res.go (0.0%)</option>
				
				<option value="file26">capstone/controllers/feedbacks/admin_feedback_controller.go (0.0%)</option>
				
				<option value="file27">capstone/controllers/feedbacks/response/feedback_res.go (0.0%)</option>
				
				<option value="file28">capstone/controllers/feedbacks/user_feedback_controller.go (0.0%)</option>
				
				<option value="file29">capstone/controllers/news/manage_news.go (0.0%)</option>
				
				<option value="file30">capstone/controllers/news/request/news_req.go (0.0%)</option>
				
				<option value="file31">capstone/controllers/news/response/news_res.go (0.0%)</option>
				
				<option value="file32">capstone/controllers/news/view_news.go (0.0%)</option>
				
				<option value="file33">capstone/main.go (0.0%)</option>
				
				<option value="file34">capstone/middlewares/jwt.go (0.0%)</option>
				
				<option value="file35">capstone/middlewares/jwt_admin.go (0.0%)</option>
				
				<option value="file36">capstone/repositories/auth/auth_repository.go (0.0%)</option>
				
				<option value="file37">capstone/repositories/auth/auth_repository_admin.go (0.0%)</option>
				
				<option value="file38">capstone/repositories/category/category_repo.go (0.0%)</option>
				
				<option value="file39">capstone/repositories/comment/user_comment.go (0.0%)</option>
				
				<option value="file40">capstone/repositories/complaints/complaint_repo.go (0.0%)</option>
				
				<option value="file41">capstone/repositories/complaints/manage_complaints_repo.go (0.0%)</option>
				
				<option value="file42">capstone/repositories/customer_service/customer_service_repo.go (0.0%)</option>
				
				<option value="file43">capstone/repositories/feedbacks/admin_feedback_repo.go (0.0%)</option>
				
				<option value="file44">capstone/repositories/feedbacks/user_feedback_repo.go (0.0%)</option>
				
				<option value="file45">capstone/repositories/models/admin.go (0.0%)</option>
				
				<option value="file46">capstone/repositories/models/ai_response_models.go (0.0%)</option>
				
				<option value="file47">capstone/repositories/models/categories.go (0.0%)</option>
				
				<option value="file48">capstone/repositories/models/comment.go (0.0%)</option>
				
				<option value="file49">capstone/repositories/models/complaints.go (0.0%)</option>
				
				<option value="file50">capstone/repositories/models/feedbacks.go (0.0%)</option>
				
				<option value="file51">capstone/repositories/models/news.go (0.0%)</option>
				
				<option value="file52">capstone/repositories/models/url_photos.go (0.0%)</option>
				
				<option value="file53">capstone/repositories/models/users.go (0.0%)</option>
				
				<option value="file54">capstone/repositories/news/manage_news.go (0.0%)</option>
				
				<option value="file55">capstone/repositories/news/view_news.go (0.0%)</option>
				
				<option value="file56">capstone/routes/routes.go (0.0%)</option>
				
				<option value="file57">capstone/services/auth/auth_service.go (70.8%)</option>
				
				<option value="file58">capstone/services/auth/auth_service_admin.go (0.0%)</option>
				
				<option value="file59">capstone/services/category/category_service.go (0.0%)</option>
				
				<option value="file60">capstone/services/comment/user_comment.go (0.0%)</option>
				
				<option value="file61">capstone/services/complaints/complaint_services.go (0.0%)</option>
				
				<option value="file62">capstone/services/complaints/manage_complaints_services.go (0.0%)</option>
				
				<option value="file63">capstone/services/customer_service/customer_service.go (0.0%)</option>
				
				<option value="file64">capstone/services/feedbacks/admin_feedback_services.go (0.0%)</option>
				
				<option value="file65">capstone/services/feedbacks/user_feedback_services.go (0.0%)</option>
				
				<option value="file66">capstone/services/news/manage_news.go (0.0%)</option>
				
				<option value="file67">capstone/services/news/view_news.go (0.0%)</option>
				
				<option value="file68">capstone/utils/strings_utils.go (50.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "os"

        "gorm.io/driver/mysql"
        "gorm.io/gorm"
)

type ConfigDB struct {
        Host     string
        User     string
        Password string
        Port     string
        Name     string
}

func ConnectDatabase() (*gorm.DB, error) <span class="cov0" title="0">{
        configDB := ConfigDB{
                Host:     os.Getenv("DATABASE_HOST"),
                User:     os.Getenv("DATABASE_USER"),
                Password: os.Getenv("DATABASE_PASSWORD"),
                Port:     os.Getenv("DATABASE_PORT"),
                Name:     os.Getenv("DATABASE_NAME"),
        }
        dsn := fmt.Sprintf("%v:%v@tcp(%v:%v)/%v?charset=utf8mb4&amp;parseTime=True&amp;loc=Local",
                configDB.User,
                configDB.Password,
                configDB.Host,
                configDB.Port,
                configDB.Name)
        db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                panic("failed connect database")</span>
        }
        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "capstone/repositories/models"
        "log"

        "gorm.io/gorm"
)

func RunMigrations(db *gorm.DB) <span class="cov0" title="0">{
        // AutoMigrate tabel
        db.AutoMigrate(
                &amp;models.Complaint{},
                &amp;models.ComplaintPhoto{},
                &amp;models.User{},
                &amp;models.Admin{},
                &amp;models.Category{},
                &amp;models.News{},
                &amp;models.Comment{},
                &amp;models.Feedback{},
                &amp;models.AIResponse{},
        )
        log.Println("Migration completed successfully!")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "capstone/controllers/auth/request"
        "capstone/controllers/auth/response"
        "capstone/services/auth"
        "net/http"

        "github.com/labstack/echo/v4"
)

type AuthController struct {
        AuthService auth.AuthServiceInterface
}

func NewAuthController(authService auth.AuthServiceInterface) *AuthController <span class="cov0" title="0">{
        return &amp;AuthController{AuthService: authService}
}</span>

func (ac *AuthController) RegisterController(c echo.Context) error <span class="cov0" title="0">{
        userRegister := request.RegisterRequest{}
        c.Bind(&amp;userRegister)

        // Panggil service untuk mendaftarkan pengguna
        user, err := ac.AuthService.RegisterUser(userRegister.ToEntities())
        if err != nil </span><span class="cov0" title="0">{
                // Periksa error untuk memberikan pesan yang lebih spesifik
                if err.Error() == "email already exists" </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusConflict, map[string]interface{}{
                                "message": "Email already exists",
                        })
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": err.Error(),
                })</span>
        }

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Registration successful",
                "user":    response.RegisterFromEntities(user),
        })</span>
}

func (uc *AuthController) VerifyOTPController(c echo.Context) error <span class="cov0" title="0">{
        type VerifyRequest struct {
                Email string `json:"email"`
                OTP   string `json:"otp"`
        }

        req := VerifyRequest{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "invalid request",
                })
        }</span>

        <span class="cov0" title="0">err := uc.AuthService.VerifyOTP(req.Email, req.OTP)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "email verified successfully",
        })</span>
}

func (uc *AuthController) LoginController(c echo.Context) error <span class="cov0" title="0">{
        userLogin := request.LoginRequest{}
        c.Bind(&amp;userLogin)
        user, err := uc.AuthService.LoginUser(userLogin.ToEntities())
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Login successful",
                "user":    response.LoginFromEntities(user),
        })</span>
}

func (ac *AuthController) GetProfile(c echo.Context) error <span class="cov0" title="0">{
        // Ambil user ID dari JWT
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]string{"message": "User not authorized"})
        }</span>

        // Panggil service untuk mendapatkan profil
        <span class="cov0" title="0">user, err := ac.AuthService.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusNotFound, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, response.UserProfileFromEntities(user))</span>
}

func (ac *AuthController) UpdateName(c echo.Context) error <span class="cov0" title="0">{
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]string{"message": "User not authorized"})
        }</span>

        <span class="cov0" title="0">req := request.UpdateNameRequest{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request payload"})
        }</span>

        <span class="cov0" title="0">user, err := ac.AuthService.UpdateName(userID, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Name updated successfully",
                "user":    response.UserProfileFromEntities(user),
        })</span>
}

func (ac *AuthController) UpdatePhoto(c echo.Context) error <span class="cov0" title="0">{
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]string{"message": "User not authorized"})
        }</span>

        <span class="cov0" title="0">req := request.UpdatePhotoRequest{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request payload"})
        }</span>

        // Validasi URL photo
        <span class="cov0" title="0">if req.PhotoURL == "" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Photo URL cannot be empty"})
        }</span>

        <span class="cov0" title="0">user, err := ac.AuthService.UpdatePhoto(userID, req.PhotoURL)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Photo updated successfully",
                "user":    response.UserProfileFromEntities(user),
        })</span>
}

func (ac *AuthController) UpdatePassword(c echo.Context) error <span class="cov0" title="0">{
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]string{"message": "User not authorized"})
        }</span>

        <span class="cov0" title="0">req := request.UpdatePasswordRequest{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request payload"})
        }</span>

        <span class="cov0" title="0">err := ac.AuthService.UpdatePassword(userID, req.OldPassword, req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]string{"message": "Password updated successfully"})</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "capstone/controllers/auth/request"
        "capstone/controllers/auth/response"
        "capstone/entities"
        "capstone/middlewares"
        "capstone/services/auth"
        "net/http"
        "strconv"

        "github.com/labstack/echo/v4"
)

type AdminController struct {
        adminService *auth.AdminService
}

// NewAdminController creates a new instance of AdminController
func NewAdminController(adminService *auth.AdminService) *AdminController <span class="cov0" title="0">{
        return &amp;AdminController{adminService: adminService}
}</span>

// RegisterAdminHandler handles admin registration
func (controller *AdminController) RegisterAdminHandler(c echo.Context) error <span class="cov0" title="0">{
        var admin entities.Admin

        // Bind JSON request body to admin struct
        if err := c.Bind(&amp;admin); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "invalid request body"})
        }</span>

        // Register admin using the service
        <span class="cov0" title="0">createdAdmin, err := controller.adminService.RegisterAdmin(admin)
        if err != nil </span><span class="cov0" title="0">{
                // Periksa error untuk memberikan pesan yang lebih spesifik
                if err.Error() == "email already exists" </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusConflict, map[string]interface{}{
                                "message": "Email Already Exists",
                        })
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": err.Error(),
                })</span>
        }

        <span class="cov0" title="0">return c.JSON(http.StatusCreated, response.RegisterAdminFromEntities(createdAdmin))</span>
}

func (controller *AdminController) LoginAdminHandler(c echo.Context) error <span class="cov0" title="0">{
        var credentials struct {
                Email    string `json:"email"`
                Password string `json:"password"`
        }

        // Bind JSON request body to credentials struct
        if err := c.Bind(&amp;credentials); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request body"})
        }</span>

        // Authenticate admin
        <span class="cov0" title="0">token, admin, err := controller.adminService.AuthenticateAdmin(credentials.Email, credentials.Password)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]string{"message": err.Error()})
        }</span>

        // Return token and admin info
        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "token": token,
                "admin": map[string]interface{}{
                        "id":    admin.ID,
                        "email": admin.Email,
                        "role":  admin.Role,
                },
        })</span>
}

// GetAllAdminsHandler handles retrieving all admins
func (controller *AdminController) GetAllAdminsHandler(c echo.Context) error <span class="cov0" title="0">{
        admins, err := controller.adminService.GetAllAdmins()
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, admins)</span>
}

// GetAdminByIDHandler handles retrieving an admin by ID
func (controller *AdminController) GetAdminByIDHandler(c echo.Context) error <span class="cov0" title="0">{
        idParam := c.Param("id")
        id, err := strconv.Atoi(idParam)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "invalid admin ID"})
        }</span>

        <span class="cov0" title="0">admin, err := controller.adminService.GetAdminByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusNotFound, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, admin)</span>
}

// UpdateAdminHandler handles updating an admin
func (controller *AdminController) UpdateAdminHandler(c echo.Context) error <span class="cov0" title="0">{
        // Parse the ID from the URL parameter
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "invalid admin ID"})
        }</span>

        <span class="cov0" title="0">var admin entities.Admin

        // Bind JSON request body to admin struct
        if err := c.Bind(&amp;admin); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "invalid request body"})
        }</span>

        // Ensure the ID in the request matches the parameter ID
        <span class="cov0" title="0">admin.ID = id

        // Update admin using the service
        updatedAdmin, err := controller.adminService.UpdateAdmin(admin)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, updatedAdmin)</span>
}

// DeleteAdminHandler handles deleting an admin by ID
func (controller *AdminController) DeleteAdminHandler(c echo.Context) error <span class="cov0" title="0">{
        idParam := c.Param("id")
        id, err := strconv.Atoi(idParam)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "invalid admin ID"})
        }</span>

        // Delete admin using the service
        <span class="cov0" title="0">if err := controller.adminService.DeleteAdmin(id); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]string{"message": "admin deleted successfully"})</span>
}

func (ac *AdminController) SomeAdminEndpoint(c echo.Context) error <span class="cov0" title="0">{
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        // Lanjutkan dengan logika endpoint
        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]string{"message": "Welcome, Admin!"})</span>
}

func (controller *AdminController) GetAdminProfile(c echo.Context) error <span class="cov0" title="0">{
        adminID, err := middlewares.ExtractAdminID(c)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]string{"message": "Unauthorized"})
        }</span>

        <span class="cov0" title="0">admin, err := controller.adminService.GetAdminByID(adminID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Admin profile fetched successfully",
                "admin":   response.AdminProfileFromEntities(admin),
        })</span>
}

func (controller *AdminController) UpdateAdminProfile(c echo.Context) error <span class="cov0" title="0">{
        adminID, err := middlewares.ExtractAdminID(c)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]string{"message": "Unauthorized"})
        }</span>

        <span class="cov0" title="0">updateRequest := request.UpdateAdminRequest{}

        if err := c.Bind(&amp;updateRequest); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request payload"})
        }</span>

        <span class="cov0" title="0">admin, err := controller.adminService.UpdateAdminProfile(adminID, updateRequest.Email, updateRequest.Password, updateRequest.Photo)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Admin profile updated successfully",
                "admin":   response.AdminProfileFromEntities(admin),
        })</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package request

import "capstone/entities"

type LoginRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required"`
}

func (loginReguest LoginRequest) ToEntities() entities.User <span class="cov0" title="0">{
        return entities.User{
                Email:    loginReguest.Email,
                Password: loginReguest.Password,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package request

import "capstone/entities"

type LoginAdminRequest struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

func (lar LoginAdminRequest) ToEntities() entities.Admin <span class="cov0" title="0">{
        return entities.Admin{
                Email:    lar.Email,
                Password: lar.Password,
        }
}</pre>
		
		<pre class="file" id="file6" style="display: none">package request

import "capstone/entities"

type RegisterRequest struct {
        ID       int    `json:"id"`
        Name     string `json:"name"`
        Phone    string `json:"phone_number"`
        Email    string `json:"email"`
        Password string `json:"password"`
        PhotoURL string `json:"photo"`
}

func (rr RegisterRequest) ToEntities() entities.User <span class="cov0" title="0">{
        return entities.User{
                ID:       rr.ID,
                Name:     rr.Name,
                Phone:    rr.Phone,
                Email:    rr.Email,
                Password: rr.Password,
                PhotoURL: rr.PhotoURL,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package request

import "capstone/entities"

type RegisterAdminRequest struct {
        ID       int    `json:"id"`
        Email    string `json:"email"`
        Password string `json:"password"`
        Role     string `json:"role"`
        Photo    string `json:"photo"`
}

func (rar RegisterAdminRequest) ToEntities() entities.Admin <span class="cov0" title="0">{
        return entities.Admin{
                ID:       rar.ID,
                Email:    rar.Email,
                Password: rar.Password,
                Role:     rar.Role,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package response

import "capstone/entities"

type AdminProfileResponse struct {
        ID       int    `json:"id"`
        Email    string `json:"email"`
        Password string `json:"password"`
        Role     string `json:"role"`
        Photo    string `json:"photo"`
}

func AdminProfileFromEntities(admin entities.Admin) AdminProfileResponse <span class="cov0" title="0">{
        return AdminProfileResponse{
                ID:       admin.ID,
                Email:    admin.Email,
                Password: admin.Password,
                Role:     admin.Role,
                Photo:    admin.Photo,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package response

import "capstone/entities"

type ErrorResponse struct {
        Message string `json:"message"`
}

type LoginUserResponse struct {
        ID    int    `json:"id"`
        Name  string `json:"name"`
        Phone string `json:"phone_number"`
        Email string `json:"email"`
        Token string `json:"token"`
}

func LoginFromEntities(user entities.User) LoginUserResponse <span class="cov0" title="0">{
        return LoginUserResponse{
                ID:    user.ID,
                Name:  user.Name,
                Phone: user.Phone,
                Email: user.Email,
                Token: user.Token,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package response

import "capstone/entities"

type LoginAdminResponse struct {
        ID        int    `json:"id"`
        Email     string `json:"email"`
        Role      string `json:"role"`
        Token     string `json:"token"`
        Message   string `json:"message"`
}

func LoginAdminFromEntities(admin entities.Admin, token string) LoginAdminResponse <span class="cov0" title="0">{
        return LoginAdminResponse{
                ID:      admin.ID,
                Email:   admin.Email,
                Role:    admin.Role,
                Token:   token,
                Message: "Login successful",
        }
}</pre>
		
		<pre class="file" id="file11" style="display: none">package response

import "capstone/entities"

type RegisterResponse struct {
        ID       int    `json:"id"`
        Name     string `json:"name"`
        Phone    string `json:"phone_number"`
        Email    string `json:"email"`
        PhotoURL string `json:"photo"`
}

func RegisterFromEntities(user entities.User) RegisterResponse <span class="cov0" title="0">{
        return RegisterResponse{
                ID:       user.ID,
                Name:     user.Name,
                Phone:    user.Phone,
                Email:    user.Email,
                PhotoURL: user.PhotoURL,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package response

import "capstone/entities"

type RegisterAdminResponse struct {
        ID    int    `json:"id"`
        Email string `json:"email"`
        Role  string `json:"role"`
        Photo string `json:"photo"`
}

func RegisterAdminFromEntities(admin entities.Admin) RegisterAdminResponse <span class="cov0" title="0">{
        return RegisterAdminResponse{
                ID:    admin.ID,
                Email: admin.Email,
                Role:  admin.Role,
                Photo: admin.Photo,
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package response

import "capstone/entities"

type UserProfileResponse struct {
        ID       int    `json:"id"`
        Name     string `json:"name"`
        Phone    string `json:"phone_number"`
        Email    string `json:"email"`
        Password string `json:"password"`
        PhotoURL string `json:"photo"`
}

func UserProfileFromEntities(user entities.User) UserProfileResponse <span class="cov0" title="0">{
        return UserProfileResponse{
                ID:       user.ID,
                Name:     user.Name,
                Phone:    user.Phone,
                Email:    user.Email,
                Password: user.Password,
                PhotoURL: user.PhotoURL,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package category

import (
        "capstone/controllers/category/request"
        "capstone/controllers/category/response"
        "capstone/services/category"
        "net/http"
        "strconv"

        "github.com/labstack/echo/v4"
)

// CategoryController defines the handlers for category-related operations
type CategoryController struct {
        service category.CategoryService
}

// NewCategoryController creates a new instance of CategoryController
func NewCategoryController(service category.CategoryService) *CategoryController <span class="cov0" title="0">{
        return &amp;CategoryController{service: service}
}</span>

// CreateCategory handles the creation of a new category
func (c *CategoryController) CreateCategory(ctx echo.Context) error <span class="cov0" title="0">{
        var req request.CategoryRequest
        if err := ctx.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request data"})
        }</span>

        <span class="cov0" title="0">createdCategory, err := c.service.CreateCategory(ctx.Request().Context(), req.ToEntity())
        if err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return ctx.JSON(http.StatusCreated, response.FromEntity(createdCategory))</span>
}

// GetCategoryByID handles retrieving a category by its ID
func (c *CategoryController) GetCategoryByID(ctx echo.Context) error <span class="cov0" title="0">{
        idParam := ctx.Param("id")
        id, err := strconv.Atoi(idParam)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid category ID"})
        }</span>

        <span class="cov0" title="0">category, err := c.service.GetCategoryByID(ctx.Request().Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusNotFound, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return ctx.JSON(http.StatusOK, response.FromEntity(category))</span>
}

// GetAllCategories handles retrieving all categories
func (c *CategoryController) GetAllCategories(ctx echo.Context) error <span class="cov0" title="0">{
        categories, err := c.service.GetAllCategories(ctx.Request().Context())
        if err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return ctx.JSON(http.StatusOK, response.FromEntities(categories))</span>
}

// UpdateCategory handles updating an existing category
func (c *CategoryController) UpdateCategory(ctx echo.Context) error <span class="cov0" title="0">{
        // Parse and validate the ID from the URL parameter
        idParam := ctx.Param("id")
        id, err := strconv.Atoi(idParam)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid category ID"})
        }</span>

        // Check if the category exists
        <span class="cov0" title="0">existingCategory, err := c.service.GetCategoryByID(ctx.Request().Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusNotFound, map[string]string{"message": "Category not found"})
        }</span>

        // Bind the request data
        <span class="cov0" title="0">var req request.UpdateCategoryRequest
        if err := ctx.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request data"})
        }</span>

        // Ensure the ID in the request matches the ID parameter
        <span class="cov0" title="0">req.ID = id

        // Convert request to entity using existing category
        updatedEntity := req.ToEntity(existingCategory)

        // Perform the update
        updatedCategory, err := c.service.UpdateCategory(ctx.Request().Context(), updatedEntity)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        // Return the updated category in the response
        <span class="cov0" title="0">return ctx.JSON(http.StatusOK, response.FromEntity(updatedCategory))</span>
}

// DeleteCategory handles deleting a category by its ID
func (c *CategoryController) DeleteCategory(ctx echo.Context) error <span class="cov0" title="0">{
        idParam := ctx.Param("id")
        id, err := strconv.Atoi(idParam)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid category ID"})
        }</span>

        <span class="cov0" title="0">err = c.service.DeleteCategory(ctx.Request().Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return ctx.JSON(http.StatusOK, map[string]string{"message": "Category deleted successfully"})</span>
}</pre>
		
		<pre class="file" id="file15" style="display: none">package request

import (
        "capstone/entities"
        "time"
)

// CategoryRequest is the struct for handling incoming request data
type CategoryRequest struct {
        Name        string `json:"name" validate:"required,min=3,max=255"`
        Description string `json:"description" validate:"max=500"`
}

// ToEntity converts CategoryRequest to Category entity
func (req *CategoryRequest) ToEntity() entities.Category <span class="cov0" title="0">{
        return entities.Category{
                Name:        req.Name,
                Description: req.Description,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }
}</span>

// UpdateCategoryRequest is the struct for handling update request data
type UpdateCategoryRequest struct {
        ID          int    `json:"id" validate:"required"`
        Name        string `json:"name" validate:"required,min=3,max=255"`
        Description string `json:"description" validate:"max=500"`
}

// ToEntity converts UpdateCategoryRequest to Category entity
func (req *UpdateCategoryRequest) ToEntity(existing entities.Category) entities.Category <span class="cov0" title="0">{
        // Use existing data as the base, only overwrite fields from the request
        return entities.Category{
                ID:          existing.ID, // Keep original ID
                Name:        req.Name,    // Update the Name
                Description: req.Description,
                CreatedAt:   existing.CreatedAt, // Preserve original CreatedAt
                UpdatedAt:   time.Now(),         // Set new UpdatedAt
        }
}</pre>
		
		<pre class="file" id="file16" style="display: none">package response

import "capstone/entities"

// CategoryResponse is the struct for sending category data as a response
type CategoryResponse struct {
        ID          int    `json:"id"`
        Name        string `json:"name"`
        Description string `json:"description"`
        CreatedAt   string `json:"created_at"`
        UpdatedAt   string `json:"updated_at"`
}

// FromEntity converts a Category entity into a CategoryResponse
func FromEntity(entity entities.Category) CategoryResponse <span class="cov0" title="0">{
        return CategoryResponse{
                ID:          entity.ID,
                Name:        entity.Name,
                Description: entity.Description,
                CreatedAt:   entity.CreatedAt.Format("2006-01-02 15:04:05"),
                UpdatedAt:   entity.UpdatedAt.Format("2006-01-02 15:04:05"),
        }
}</span>

// FromEntities converts a slice of Category entities into a slice of CategoryResponse
func FromEntities(entities []entities.Category) []CategoryResponse <span class="cov0" title="0">{
        var responses []CategoryResponse
        for _, entity := range entities </span><span class="cov0" title="0">{
                responses = append(responses, FromEntity(entity))
        }</span>
        <span class="cov0" title="0">return responses</span>
}</pre>
		
		<pre class="file" id="file17" style="display: none">package request

import "capstone/entities"

type AddCommentRequest struct {
        NewsID  int    `json:"news_id" validate:"required"`
        Content string `json:"content" validate:"required"`
}

// Konversi ke entitas
func (req AddCommentRequest) ToEntity(userID int) entities.Comment <span class="cov0" title="0">{
        return entities.Comment{
                UserID:  userID,
                NewsID:  req.NewsID,
                Content: req.Content,
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package response

import (
        "capstone/entities"
        "time"
)

type CommentResponse struct {
        ID      int          `json:"id"`
        Content string       `json:"content"`
        User    UserResponse `json:"user"`
        News    NewsResponse `json:"news"`
}

type UserResponse struct {
        ID    int    `json:"id"`
        Name  string `json:"name"`
        Email string `json:"email"`
        Phone string `json:"phone_number"`
}

type NewsResponse struct {
        ID        int       `json:"id"`
        Title     string    `json:"title"`
        Content   string    `json:"content"`
        PhotoURL  string    `json:"photo_url"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

func FromEntityComment(comment entities.Comment) CommentResponse <span class="cov0" title="0">{
        return CommentResponse{
                ID:      comment.ID,
                Content: comment.Content,
                User: UserResponse{
                        ID:    comment.User.ID,
                        Name:  comment.User.Name,
                        Email: comment.User.Email,
                        Phone: comment.User.Phone,
                },
                News: NewsResponse{
                        ID:        comment.News.ID,
                        Title:     comment.News.Title,
                        Content:   comment.News.Content,
                        PhotoURL:  comment.News.PhotoURL,
                        CreatedAt: comment.News.CreatedAt,
                        UpdatedAt: comment.News.UpdatedAt,
                },
        }
}</span>

func FromEntityComments(comments []entities.Comment) []CommentResponse <span class="cov0" title="0">{
        var responses []CommentResponse
        for _, comment := range comments </span><span class="cov0" title="0">{
                responses = append(responses, FromEntityComment(comment))
        }</span>
        <span class="cov0" title="0">return responses</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package comment

import (
        "capstone/controllers/comment/request"
        "capstone/controllers/comment/response"
        "capstone/services/comment"
        "net/http"

        "github.com/labstack/echo/v4"
)

type CommentController struct {
        commentService comment.CommentServiceInterface
}

func NewCommentController(service comment.CommentServiceInterface) *CommentController <span class="cov0" title="0">{
        return &amp;CommentController{commentService: service}
}</span>

func (cc *CommentController) AddComment(c echo.Context) error <span class="cov0" title="0">{
        req := request.AddCommentRequest{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "Invalid request",
                })
        }</span>

        // Ambil UserID dari middleware
        <span class="cov0" title="0">userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>

        // Konversi request ke entitas
        <span class="cov0" title="0">commentEntity := req.ToEntity(userID)

        // Tambahkan komentar melalui service
        comment, err := cc.commentService.AddComment(commentEntity)
        if err != nil </span><span class="cov0" title="0">{
                // Menangkap error yang lebih spesifik dari service
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Comment added successfully",
                "comment": response.FromEntityComment(comment),
        })</span>
}

func (cc CommentController) GetCommentsByUser(c echo.Context) error <span class="cov0" title="0">{
        // Ambil user_id dari JWT di context
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>

        // Ambil data komentar berdasarkan user_id dari service
        <span class="cov0" title="0">comments, err := cc.commentService.GetCommentsByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]interface{}{
                        "message": "Failed to retrieve comments",
                })
        }</span>

        // Konversi response
        <span class="cov0" title="0">commentResponses := response.FromEntityComments(comments)

        return c.JSON(http.StatusOK, map[string]interface{}{
                "message":  "Comments retrieved successfully",
                "comments": commentResponses,
        })</span>
}

func (cc *CommentController) GetAllComments(c echo.Context) error <span class="cov0" title="0">{
        // Ambil semua komentar dari service
        comments, err := cc.commentService.GetAllComments()
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]interface{}{
                        "message": "Failed to retrieve all comments",
                })
        }</span>

        // Konversi komentar ke response
        <span class="cov0" title="0">commentResponses := response.FromEntityComments(comments)

        return c.JSON(http.StatusOK, map[string]interface{}{
                "message":  "All comments retrieved successfully",
                "comments": commentResponses,
        })</span>
}

func (cc *CommentController) GetCommentByID(c echo.Context) error <span class="cov0" title="0">{
        // Ambil ID dari parameter URL
        commentID := c.Param("id")

        // Ambil detail komentar dari service
        comment, err := cc.commentService.GetCommentByID(commentID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusNotFound, map[string]interface{}{
                        "message": "Komentar Tidak Ditemukan",
                })
        }</span>

        // Konversi komentar ke response
        <span class="cov0" title="0">commentResponse := response.FromEntityComment(comment)

        return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Comment retrieved successfully",
                "comment": commentResponse,
        })</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package complaints

import (
        "capstone/controllers/complaints/request"
        "capstone/controllers/complaints/response"
        "capstone/services/complaints"
        "net/http"
        "strconv"

        "github.com/labstack/echo/v4"
)

type ComplaintController struct {
        complaintService complaints.ComplaintServiceInterface
}

func NewComplaintController(cs complaints.ComplaintServiceInterface) *ComplaintController <span class="cov0" title="0">{
        return &amp;ComplaintController{complaintService: cs}
}</span>

func (cc *ComplaintController) CreateComplaintController(c echo.Context) error <span class="cov0" title="0">{
        req := request.CreateComplaintRequest{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "invalid request",
                })
        }</span>

        // Ambil UserID dari context (disimpan oleh middleware `GetUserID`)
        <span class="cov0" title="0">userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>
        <span class="cov0" title="0">req.UserID = userID

        // Ekstrak foto dari request
        photoURLs := req.PhotoURLs // Tambahkan di request JSON

        err := cc.complaintService.ValidateCategoryID(req.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "Kategori Tidak Valid",
                })
        }</span>

        <span class="cov0" title="0">complaint, photos, err := cc.complaintService.CreateComplaint(req.ToEntity(), photoURLs)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message":   "Complaint created successfully",
                "complaint": response.ComplaintFromEntitiesWithPhoto(complaint, photos),
        })</span>
}

func (cc *ComplaintController) GetUserComplaintsByStatusAndCategory(c echo.Context) error <span class="cov0" title="0">{
        // Ambil user_id dari JWT
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]string{"message": "User not authorized"})
        }</span>

        // Ambil parameter query
        <span class="cov0" title="0">status := c.QueryParam("status")
        categoryIDParam := c.QueryParam("category_id")
        pageParam := c.QueryParam("page")
        limitParam := c.QueryParam("limit")

        // Konversi categoryID, page, dan limit jika ada
        var categoryID, page, limit int
        var err error
        if categoryIDParam != "" </span><span class="cov0" title="0">{
                categoryID, err = strconv.Atoi(categoryIDParam)
                if err != nil </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid category ID"})
                }</span>
        }
        <span class="cov0" title="0">page, _ = strconv.Atoi(pageParam)   // Default 0 jika kosong
        limit, _ = strconv.Atoi(limitParam) // Default 0 jika kosong

        // Ambil data keluhan dari service
        complaints, total, err := cc.complaintService.GetUserComplaintsByStatusAndCategory(userID, status, categoryID, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        // Konversi entities ke response
        <span class="cov0" title="0">responseData := response.ComplaintsFromEntities(complaints)

        // Kirim respons dengan data dan metadata pagination
        return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Success",
                "data": map[string]interface{}{
                        "complaints": responseData,
                        "total":      total,
                        "page":       page,
                        "limit":      limit,
                },
        })</span>
}

func (cc *ComplaintController) GetComplaintById(c echo.Context) error <span class="cov0" title="0">{
        // Ambil ID dari parameter URL
        complaintID, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "Invalid Complaint ID",
                })
        }</span>

        // Ambil user_id dari JWT di context
        <span class="cov0" title="0">userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>

        // Ambil data keluhan dari service
        <span class="cov0" title="0">complaint, err := cc.complaintService.GetComplaintByIDAndUser(complaintID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusNotFound, map[string]interface{}{
                        "message": "Pengaduan Tidak Ditemukan",
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message":   "Complaint status retrieved successfully",
                "complaint": response.ComplaintFromEntitiesWithPhoto(complaint, complaint.Photos),
        })</span>
}

func (cc *ComplaintController) GetComplaintByUser(c echo.Context) error <span class="cov0" title="0">{
        // Ambil user_id dari JWT di context
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>

        // Ambil keluhan berdasarkan user_id
        <span class="cov0" title="0">complaints, err := cc.complaintService.GetComplaintsByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]interface{}{
                        "message": "Failed to retrieve complaints",
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message":    "Complaints retrieved successfully",
                "complaints": response.ComplaintsFromEntities(complaints),
        })</span>
}

func (cc *ComplaintController) GetComplaintsByStatus(c echo.Context) error <span class="cov0" title="0">{
        // Ambil status dari parameter URL
        status := c.Param("status")

        // Validasi status
        validStatuses := []string{"proses", "tanggapi", "batal", "selesai"}
        isValid := false
        for _, validStatus := range validStatuses </span><span class="cov0" title="0">{
                if status == validStatus </span><span class="cov0" title="0">{
                        isValid = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "Invalid status value",
                })
        }</span>

        // Ambil user_id dari JWT di context
        <span class="cov0" title="0">userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>

        // Ambil data keluhan berdasarkan status dan user_id dari service
        <span class="cov0" title="0">complaints, err := cc.complaintService.GetComplaintsByStatusAndUser(status, userID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]interface{}{
                        "message": "Failed to retrieve complaints",
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message":    "Complaints retrieved successfully",
                "complaints": response.ComplaintsFromEntities(complaints),
        })</span>
}

func (cc *ComplaintController) GetAllComplaintsByUser(c echo.Context) error <span class="cov0" title="0">{
        // Ambil user_id dari JWT di context
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>

        // Ambil semua data complaints milik user
        <span class="cov0" title="0">complaints, err := cc.complaintService.GetAllComplaintsByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]interface{}{
                        "message": "Failed to retrieve complaints",
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message":    "Complaints retrieved successfully",
                "complaints": response.ComplaintsFromEntities(complaints),
        })</span>
}

func (cc ComplaintController) GetComplaintsByCategory(c echo.Context) error <span class="cov0" title="0">{
        // Ambil ID kategori dari parameter URL
        categoryID, err := strconv.Atoi(c.Param("category_id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "Invalid Category ID",
                })
        }</span>

        // Ambil user_id dari JWT di context
        <span class="cov0" title="0">userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>

        <span class="cov0" title="0">err = cc.complaintService.ValidateCategoryID(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "Kategori Tidak Valid",
                })
        }</span>

        // Ambil keluhan berdasarkan kategori dan user_id
        <span class="cov0" title="0">complaints, err := cc.complaintService.GetComplaintsByCategoryAndUser(categoryID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]interface{}{
                        "message": "Failed to retrieve complaints",
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message":    "Complaints retrieved successfully",
                "complaints": response.ComplaintsFromEntities(complaints),
        })</span>
}

func (cc *ComplaintController) CancelComplaint(c echo.Context) error <span class="cov0" title="0">{
        // Ambil User ID dari middleware
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User tidak memiliki otorisasi",
                })
        }</span>

        // Ambil complaint ID dari parameter
        <span class="cov0" title="0">complaintID, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "ID pengaduan tidak valid",
                })
        }</span>

        // Ambil data alasan pembatalan dari body
        <span class="cov0" title="0">var request struct {
                Reason string `json:"reason" validate:"required"`
        }
        if err := c.Bind(&amp;request); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "Data pembatalan tidak valid",
                })
        }</span>

        // Proses pembatalan melalui service
        <span class="cov0" title="0">updatedComplaint, err := cc.complaintService.CancelComplaint(complaintID, userID, request.Reason)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>

        // Kembalikan respons dengan data pengaduan yang telah diperbarui
        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message":   "Pengaduan berhasil dibatalkan",
                "complaint": response.ComplaintFromEntitiesWithReason(updatedComplaint, updatedComplaint.Photos),
        })</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package complaints

import (
        "capstone/controllers/complaints/request"
        "capstone/controllers/complaints/response"
        "capstone/middlewares"
        "net/http"
        "strconv"

        "github.com/labstack/echo/v4"
)

func (cc *ComplaintController) GetComplaintsByStatusAndCategory(c echo.Context) error <span class="cov0" title="0">{
        // Validasi role admin
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        // Ambil parameter query
        <span class="cov0" title="0">status := c.QueryParam("status")
        categoryIDParam := c.QueryParam("category_id")
        pageParam := c.QueryParam("page")
        limitParam := c.QueryParam("limit")

        // Konversi categoryID, page, dan limit jika ada
        var categoryID, page, limit int
        if categoryIDParam != "" </span><span class="cov0" title="0">{
                categoryID, err = strconv.Atoi(categoryIDParam)
                if err != nil </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid category ID"})
                }</span>
        }
        <span class="cov0" title="0">page, _ = strconv.Atoi(pageParam)   // Default 0 jika kosong
        limit, _ = strconv.Atoi(limitParam) // Default 0 jika kosong

        // Ambil data dari service
        complaints, total, err := cc.complaintService.GetComplaintsByStatusAndCategory(status, categoryID, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        // Konversi entities ke response
        <span class="cov0" title="0">responseData := response.ComplaintsFromEntities(complaints)

        // Kirim respons dengan data dan metadata pagination
        return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Success",
                "data": map[string]interface{}{
                        "complaints": responseData,
                        "total":      total,
                        "page":       page,
                        "limit":      limit,
                },
        })</span>
}

func (cc *ComplaintController) GetComplaintDetailByAdmin(c echo.Context) error <span class="cov0" title="0">{
        // Validasi role admin
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        // Ambil complaint ID dari parameter
        <span class="cov0" title="0">complaintID, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid complaint ID"})
        }</span>

        // Ambil detail complaint dari service
        <span class="cov0" title="0">complaint, err := cc.complaintService.GetComplaintDetailByID(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        // Konversi ke response dengan feedback
        <span class="cov0" title="0">response := response.ComplaintFromEntitiesWithFeedback(complaint)

        return c.JSON(http.StatusOK, map[string]interface{}{
                "message":   "Complaint detail retrieved successfully",
                "complaint": response,
        })</span>
}

func (cc *ComplaintController) UpdateComplaintByAdmin(c echo.Context) error <span class="cov0" title="0">{
        // Validasi role admin
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        // Ambil AdminID dari token JWT
        <span class="cov0" title="0">adminID, ok := c.Get("admin_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]string{"message": "Invalid admin token"})
        }</span>

        // Ambil ID pengaduan dari parameter
        <span class="cov0" title="0">complaintID, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid complaint ID"})
        }</span>

        // Bind data dari request body
        <span class="cov0" title="0">request := request.RequestUpdateComplaint{}
        if err := c.Bind(&amp;request); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request body"})
        }</span>

        // Masukkan AdminID ke dalam data pembaruan
        <span class="cov0" title="0">updateData := request.ToEntity()

        // Pastikan AdminID diinisialisasi jika nil
        if updateData.AdminID == nil </span><span class="cov0" title="0">{
                updateData.AdminID = new(int) // Alokasikan memori untuk pointer AdminID
        }</span>
        <span class="cov0" title="0">*updateData.AdminID = adminID

        // Update data pengaduan melalui service
        err = cc.complaintService.UpdateComplaintByAdmin(complaintID, updateData)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        // Ambil data complaint yang telah diperbarui
        <span class="cov0" title="0">complaint, err := cc.complaintService.GetComplaintByID(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": "Failed to fetch updated complaint"})
        }</span>

        // Kirim respons
        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message":   "Complaint updated successfully",
                "complaint": response.ComplaintFromEntitiesWithAdmin(complaint),
        })</span>
}

func (cc *ComplaintController) DeleteComplaintByAdmin(c echo.Context) error <span class="cov0" title="0">{
        // Validasi role admin
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        // Ambil ID pengaduan dari parameter
        <span class="cov0" title="0">complaintID, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid complaint ID"})
        }</span>

        // Hapus complaint melalui service
        <span class="cov0" title="0">err = cc.complaintService.DeleteComplaintByAdmin(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": err.Error()})
        }</span>

        // Kirim respons
        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]string{"message": "Complaint deleted successfully"})</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package request

import "capstone/entities"

type CreateComplaintRequest struct {
        UserID          int      `json:"user_id" validate:"required"`
        ComplaintNumber string   `json:"complaint_number"`
        Title           string   `json:"title"`
        Location        string   `json:"location"`
        CategoryID      int      `json:"category_id" validate:"required"`
        Description     string   `json:"description" validate:"required"`
        PhotoURLs       []string `json:"photo_urls"`
}

func (req CreateComplaintRequest) ToEntity() entities.Complaint <span class="cov0" title="0">{
        return entities.Complaint{
                UserID:          req.UserID,
                CategoryID:      req.CategoryID,
                ComplaintNumber: req.ComplaintNumber,
                Title:           req.Title,
                Location:        req.Location,
                Description:     req.Description,
        }
}</span>

// Bind data dari request body
type RequestUpdateComplaint struct {
        CategoryID      int    `json:"category_id"`
        Title           string `json:"title"`
        Location        string `json:"location"`
        Status          string `json:"status"`
        Description     string `json:"description"`
        ComplaintNumber string `json:"complaint_number"`
}

func (req RequestUpdateComplaint) ToEntity() entities.Complaint <span class="cov0" title="0">{
        return entities.Complaint{
                CategoryID:      req.CategoryID,
                Title:           req.Title,
                Location:        req.Location,
                Status:          req.Status,
                Description:     req.Description,
                ComplaintNumber: req.ComplaintNumber,
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package response

import (
        "capstone/entities"
        "time"
)

type CreateComplaintResponse struct {
        ID              int        `json:"id"`
        User            User       `json:"user"`
        Category        Category   `json:"category"`
        ComplaintNumber string     `json:"complaint_number"`
        Title           string     `json:"title"`
        Location        string     `json:"location"`
        Status          string     `json:"status"`
        Feedbacks       []Feedback `json:"feedback"`
        Description     string     `json:"description" validate:"required"`
        CreatedAt       time.Time  `json:"created_at"`
        UpdatedAt       time.Time  `json:"updated_at"`
}

type CreateComplaintResponseWithPhoto struct {
        ID              int              `json:"id"`
        User            User             `json:"user"`
        Category        Category         `json:"category"`
        ComplaintNumber string           `json:"complaint_number"`
        Title           string           `json:"title"`
        Location        string           `json:"location"`
        Status          string           `json:"status"`
        Description     string           `json:"description" validate:"required"`
        Photos          []ComplaintPhoto `json:"photos"`
        Feedbacks       []Feedback       `json:"feedback"`
        CreatedAt       time.Time        `json:"created_at"`
        UpdatedAt       time.Time        `json:"updated_at"`
}

type CreateComplaintResponseWithReason struct {
        ID              int              `json:"id"`
        User            User             `json:"user"`
        Category        Category         `json:"category"`
        ComplaintNumber string           `json:"complaint_number"`
        Title           string           `json:"title"`
        Location        string           `json:"location"`
        Status          string           `json:"status"`
        Description     string           `json:"description" validate:"required"`
        Photos          []ComplaintPhoto `json:"photos"`
        Reason          string           `json:"reason"`
        CreatedAt       time.Time        `json:"created_at"`
        UpdatedAt       time.Time        `json:"updated_at"`
}

type CreateComplaintResponseWithAdmin struct {
        ID              int              `json:"id"`
        Admin           Admin            `json:"Admin"`
        User            User             `json:"user"`
        Category        Category         `json:"category"`
        ComplaintNumber string           `json:"complaint_number"`
        Title           string           `json:"title"`
        Location        string           `json:"location"`
        Status          string           `json:"status"`
        Description     string           `json:"description" validate:"required"`
        Photos          []ComplaintPhoto `json:"photos"`
        Feedbacks       []Feedback       `json:"feedback"`
        Reason          string           `json:"reason"`
        CreatedAt       time.Time        `json:"created_at"`
        UpdatedAt       time.Time        `json:"updated_at"`
}
type User struct {
        ID    int    `json:"id"`
        Name  string `json:"name"`
        Phone string `json:"phone_number"`
        Email string `json:"email"`
}

type Category struct {
        ID          int       `json:"id"`
        Name        string    `json:"name"`
        Description string    `json:"description"`
        CreatedAt   time.Time `json:"create_at"`
        UpdatedAt   time.Time `json:"update_at"`
}

type ComplaintPhoto struct {
        ID       int    `json:"id"`
        PhotoURL string `json:"photo_url"`
}

type Admin struct {
        ID    int    `json:"id"`
        Email string `json:"email"`
        Role  string `json:"role"`
}

type Feedback struct {
        ID        int       `json:"id"`
        Admin     Admin     `json:"admin"`
        Content   string    `json:"content"`
        CreatedAt time.Time `json:"created_at"`
}

// Fungsi untuk membuat respons dari entities.Complaint
func ComplaintFromEntitiesWithPhoto(complaint entities.Complaint, photos []entities.ComplaintPhoto) CreateComplaintResponseWithPhoto <span class="cov0" title="0">{
        // Konversi photos dari entities ke response
        var photoResponses []ComplaintPhoto
        for _, photo := range photos </span><span class="cov0" title="0">{
                photoResponses = append(photoResponses, ComplaintPhoto{
                        ID:       photo.ID,
                        PhotoURL: photo.PhotoURL,
                })
        }</span>

        // Konversi feedbacks
        <span class="cov0" title="0">var feedbackResponses []Feedback
        for _, feedback := range complaint.Feedbacks </span><span class="cov0" title="0">{
                feedbackResponses = append(feedbackResponses, Feedback{
                        ID: feedback.ID,
                        Admin: Admin{
                                ID:    feedback.Admin.ID,
                                Email: feedback.Admin.Email,
                                Role:  feedback.Admin.Role,
                        },
                        Content:   feedback.Content,
                        CreatedAt: feedback.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return CreateComplaintResponseWithPhoto{
                ID: complaint.ID,
                User: User{
                        ID:    complaint.User.ID,
                        Name:  complaint.User.Name,
                        Phone: complaint.User.Phone,
                        Email: complaint.User.Email,
                },
                Category: Category{
                        ID:          complaint.Category.ID,
                        Name:        complaint.Category.Name,
                        Description: complaint.Category.Description,
                        CreatedAt:   complaint.Category.CreatedAt,
                        UpdatedAt:   complaint.Category.UpdatedAt,
                },
                ComplaintNumber: complaint.ComplaintNumber,
                Title:           complaint.Title,
                Location:        complaint.Location,
                Status:          complaint.Status,
                Description:     complaint.Description,
                Photos:          photoResponses,
                Feedbacks:       feedbackResponses,
                CreatedAt:       complaint.CreatedAt,
                UpdatedAt:       complaint.UpdatedAt,
        }</span>
}

func ComplaintFromEntities(complaint entities.Complaint) CreateComplaintResponse <span class="cov0" title="0">{

        // Konversi feedbacks
        var feedbackResponses []Feedback
        for _, feedback := range complaint.Feedbacks </span><span class="cov0" title="0">{
                feedbackResponses = append(feedbackResponses, Feedback{
                        ID: feedback.ID,
                        Admin: Admin{
                                ID:    feedback.Admin.ID,
                                Email: feedback.Admin.Email,
                                Role:  feedback.Admin.Role,
                        },
                        Content:   feedback.Content,
                        CreatedAt: feedback.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return CreateComplaintResponse{
                ID: complaint.ID,
                User: User{
                        ID:    complaint.User.ID,
                        Name:  complaint.User.Name,
                        Phone: complaint.User.Phone,
                        Email: complaint.User.Email,
                },
                Category: Category{
                        ID:          complaint.Category.ID,
                        Name:        complaint.Category.Name,
                        Description: complaint.Category.Description,
                        CreatedAt:   complaint.Category.CreatedAt,
                        UpdatedAt:   complaint.Category.UpdatedAt,
                },
                ComplaintNumber: complaint.ComplaintNumber,
                Title:           complaint.Title,
                Location:        complaint.Location,
                Status:          complaint.Status,
                Description:     complaint.Description,
                Feedbacks:       feedbackResponses,
                CreatedAt:       complaint.CreatedAt,
                UpdatedAt:       complaint.UpdatedAt,
        }</span>
}

func ComplaintsFromEntities(complaints []entities.Complaint) []CreateComplaintResponseWithPhoto <span class="cov0" title="0">{
        var responses []CreateComplaintResponseWithPhoto
        for _, complaint := range complaints </span><span class="cov0" title="0">{
                // Konversi daftar foto
                var photoResponses []ComplaintPhoto
                for _, photo := range complaint.Photos </span><span class="cov0" title="0">{
                        photoResponses = append(photoResponses, ComplaintPhoto{
                                ID:       photo.ID,
                                PhotoURL: photo.PhotoURL,
                        })
                }</span>

                // Konversi feedbacks
                <span class="cov0" title="0">var feedbackResponses []Feedback
                for _, feedback := range complaint.Feedbacks </span><span class="cov0" title="0">{
                        feedbackResponses = append(feedbackResponses, Feedback{
                                ID: feedback.ID,
                                Admin: Admin{
                                        ID:    feedback.Admin.ID,
                                        Email: feedback.Admin.Email,
                                        Role:  feedback.Admin.Role,
                                },
                                Content:   feedback.Content,
                                CreatedAt: feedback.CreatedAt,
                        })
                }</span>

                // Periksa apakah kategori tersedia
                <span class="cov0" title="0">var categoryResponse Category
                if complaint.Category.ID &gt; 0 </span><span class="cov0" title="0">{
                        categoryResponse = Category{
                                ID:          complaint.Category.ID,
                                Name:        complaint.Category.Name,
                                Description: complaint.Category.Description,
                                CreatedAt:   complaint.Category.CreatedAt,
                                UpdatedAt:   complaint.Category.UpdatedAt,
                        }
                }</span>

                // Tambahkan respons
                <span class="cov0" title="0">responses = append(responses, CreateComplaintResponseWithPhoto{
                        ID: complaint.ID,
                        User: User{
                                ID:    complaint.User.ID,
                                Name:  complaint.User.Name,
                                Phone: complaint.User.Phone,
                                Email: complaint.User.Email,
                        },
                        Category:        categoryResponse,
                        ComplaintNumber: complaint.ComplaintNumber,
                        Title:           complaint.Title,
                        Location:        complaint.Location,
                        Status:          complaint.Status,
                        Description:     complaint.Description,
                        Photos:          photoResponses,
                        Feedbacks:       feedbackResponses,
                        CreatedAt:       complaint.CreatedAt,
                        UpdatedAt:       complaint.UpdatedAt,
                })</span>
        }
        <span class="cov0" title="0">return responses</span>
}

func ComplaintFromEntitiesWithReason(complaint entities.Complaint, photos []entities.ComplaintPhoto) CreateComplaintResponseWithReason <span class="cov0" title="0">{
        var photoResponses []ComplaintPhoto
        for _, photo := range photos </span><span class="cov0" title="0">{
                photoResponses = append(photoResponses, ComplaintPhoto{
                        ID:       photo.ID,
                        PhotoURL: photo.PhotoURL,
                })
        }</span>

        <span class="cov0" title="0">return CreateComplaintResponseWithReason{
                ID: complaint.ID,
                User: User{
                        ID:    complaint.User.ID,
                        Name:  complaint.User.Name,
                        Phone: complaint.User.Phone,
                        Email: complaint.User.Email,
                },
                Category: Category{
                        ID:          complaint.Category.ID,
                        Name:        complaint.Category.Name,
                        Description: complaint.Category.Description,
                        CreatedAt:   complaint.Category.CreatedAt,
                        UpdatedAt:   complaint.Category.UpdatedAt,
                },
                ComplaintNumber: complaint.ComplaintNumber,
                Title:           complaint.Title,
                Location:        complaint.Location,
                Status:          complaint.Status,
                Description:     complaint.Description,
                Photos:          photoResponses,
                Reason:          complaint.Reason, // Alasan pembatalan
                CreatedAt:       complaint.CreatedAt,
                UpdatedAt:       complaint.UpdatedAt,
        }</span>
}

func ComplaintFromEntitiesWithAdmin(complaint entities.Complaint) CreateComplaintResponseWithAdmin <span class="cov0" title="0">{
        // Konversi daftar foto
        var photoResponses []ComplaintPhoto
        for _, photo := range complaint.Photos </span><span class="cov0" title="0">{
                photoResponses = append(photoResponses, ComplaintPhoto{
                        ID:       photo.ID,
                        PhotoURL: photo.PhotoURL,
                })
        }</span>

        // Konversi feedbacks
        <span class="cov0" title="0">var feedbackResponses []Feedback
        for _, feedback := range complaint.Feedbacks </span><span class="cov0" title="0">{
                feedbackResponses = append(feedbackResponses, Feedback{
                        ID: feedback.ID,
                        Admin: Admin{
                                ID:    feedback.Admin.ID,
                                Email: feedback.Admin.Email,
                                Role:  feedback.Admin.Role,
                        },
                        Content:   feedback.Content,
                        CreatedAt: feedback.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return CreateComplaintResponseWithAdmin{
                ID: complaint.ID,
                Admin: Admin{
                        ID:    complaint.Admin.ID,
                        Email: complaint.Admin.Email,
                        Role:  complaint.Admin.Role,
                },
                User: User{
                        ID:    complaint.User.ID,
                        Name:  complaint.User.Name,
                        Phone: complaint.User.Phone,
                        Email: complaint.User.Email,
                },
                Category: Category{
                        ID:          complaint.Category.ID,
                        Name:        complaint.Category.Name,
                        Description: complaint.Category.Description,
                        CreatedAt:   complaint.Category.CreatedAt,
                        UpdatedAt:   complaint.Category.UpdatedAt,
                },
                ComplaintNumber: complaint.ComplaintNumber,
                Title:           complaint.Title,
                Location:        complaint.Location,
                Status:          complaint.Status,
                Description:     complaint.Description,
                Photos:          photoResponses,
                Reason:          complaint.Reason,
                Feedbacks:       feedbackResponses,
                CreatedAt:       complaint.CreatedAt,
                UpdatedAt:       complaint.UpdatedAt,
        }</span>
}

func ComplaintFromEntitiesWithFeedback(complaint entities.Complaint) CreateComplaintResponseWithAdmin <span class="cov0" title="0">{
        var photoResponses []ComplaintPhoto
        for _, photo := range complaint.Photos </span><span class="cov0" title="0">{
                photoResponses = append(photoResponses, ComplaintPhoto{
                        ID:       photo.ID,
                        PhotoURL: photo.PhotoURL,
                })
        }</span>

        // Konversi feedbacks
        <span class="cov0" title="0">var feedbackResponses []Feedback
        for _, feedback := range complaint.Feedbacks </span><span class="cov0" title="0">{
                feedbackResponses = append(feedbackResponses, Feedback{
                        ID: feedback.ID,
                        Admin: Admin{
                                ID:    feedback.Admin.ID,
                                Email: feedback.Admin.Email,
                                Role:  feedback.Admin.Role,
                        },
                        Content:   feedback.Content,
                        CreatedAt: feedback.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return CreateComplaintResponseWithAdmin{
                ID: complaint.ID,
                Admin: Admin{
                        ID:    complaint.Admin.ID,
                        Email: complaint.Admin.Email,
                        Role:  complaint.Admin.Role,
                },
                User: User{
                        ID:    complaint.User.ID,
                        Name:  complaint.User.Name,
                        Phone: complaint.User.Phone,
                        Email: complaint.User.Email,
                },
                Category: Category{
                        ID:          complaint.Category.ID,
                        Name:        complaint.Category.Name,
                        Description: complaint.Category.Description,
                        CreatedAt:   complaint.Category.CreatedAt,
                        UpdatedAt:   complaint.Category.UpdatedAt,
                },
                ComplaintNumber: complaint.ComplaintNumber,
                Title:           complaint.Title,
                Location:        complaint.Location,
                Status:          complaint.Status,
                Description:     complaint.Description,
                Photos:          photoResponses,
                Reason:          complaint.Reason,
                Feedbacks:       feedbackResponses,
                CreatedAt:       complaint.CreatedAt,
                UpdatedAt:       complaint.UpdatedAt,
        }</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package customerservice

import (
        "capstone/controllers/customer_service/request"
        "capstone/controllers/customer_service/response"
        customerservice "capstone/services/customer_service"
        "context"
        "encoding/json"
        "net/http"
        "os"
        "strconv"
        "strings"

        "github.com/google/generative-ai-go/genai"
        "github.com/labstack/echo/v4"
        "google.golang.org/api/option"
)

type CustomerServiceController struct {
        customerService customerservice.CustomerServiceInterface
}

func NewCustomerServiceController(cs customerservice.CustomerServiceInterface) *CustomerServiceController <span class="cov0" title="0">{
        return &amp;CustomerServiceController{customerService: cs}
}</span>

func (controller *CustomerServiceController) ChatbotQueryController(c echo.Context) error <span class="cov0" title="0">{
        // Ambil user_id dari JWT di context
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>

        // Ambil data user terkait
        <span class="cov0" title="0">user, err := controller.customerService.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": "Failed to get user data"})
        }</span>

        <span class="cov0" title="0">request := request.RequestCS{}
        // Ambil pertanyaan dari body request
        if err := c.Bind(&amp;request); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request format"})
        }</span>

        // Normalize query
        <span class="cov0" title="0">query := strings.ToLower(strings.TrimSpace(request.Query))

        // Check for static response
        if responseCS, exists := staticResponses[query]; exists </span><span class="cov0" title="0">{
                return response.SuccessResponse(c, user, request.Query, responseCS)
        }</span>

        // Siapkan konteks dan client AI
        <span class="cov0" title="0">ctx := context.Background()
        apiKey := os.Getenv("TOKEN_AI")
        client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": "Failed to initialize AI client"})
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // Tentukan model AI yang digunakan
        model := client.GenerativeModel("gemini-1.5-flash")
        model.SetTemperature(0.7)

        // Tambahkan konteks aplikasi Laporin
        genAIParts := []genai.Part{
                genai.Text("Halo, saya adalah Lapi, anggota tim Laporin, sebuah aplikasi untuk membantu pengaduan masyarakat."),
                genai.Text(Sapaan),
                genai.Text(DeskripsiLaporin),
                genai.Text(CaraMengajukanPengaduan),
                genai.Text(CaraMelihatStatusPengaduan),
                genai.Text(CaraMembatalkanPengaduan),
                genai.Text(CaraMembacaBeritaDanPengumuman),
                genai.Text("Pertanyaan dari user: " + request.Query),
                genai.Text("Berikan jawaban yang spesifik, jelas, dan terkait dengan layanan Laporin."),
                genai.Text(DiluarTopik),
        }

        // Kirim permintaan ke model AI
        resp, err := model.GenerateContent(ctx, genAIParts...)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": "Failed to get AI response"})
        }</span>

        // Ambil respons AI
        <span class="cov0" title="0">aiResponse := resp.Candidates[0].Content.Parts[0]

        aiResponseString, err := json.Marshal(aiResponse)
        // cleanedResponse := cleanAIResponse(string(aiResponseString))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to marshal care suggestion"})
        }</span>

        // Simpan respons ke database
        <span class="cov0" title="0">err = controller.customerService.SaveAIResponse(userID, request.Query, string(aiResponseString))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{"message": "Failed to save AI response"})
        }</span>

        // Kirimkan respons ke user
        <span class="cov0" title="0">return response.SuccessResponse(c, user, request.Query, string(aiResponseString))</span>
}

func (controller *CustomerServiceController) GetUserResponses(c echo.Context) error <span class="cov0" title="0">{
        // Ambil user_id dari JWT di context
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>

        // Ambil parameter pagination
        <span class="cov0" title="0">page, err := strconv.Atoi(c.QueryParam("page"))
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">limit, err := strconv.Atoi(c.QueryParam("limit"))
        if err != nil || limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        // Ambil data customer service untuk user tertentu
        <span class="cov0" title="0">responses, total, err := controller.customerService.GetUserResponses(userID, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{
                        "message": "Failed to retrieve data",
                })
        }</span>

        // Hitung total halaman
        <span class="cov0" title="0">totalPages := (total + limit - 1) / limit

        // Kirimkan respons ke user
        return c.JSON(http.StatusOK, map[string]interface{}{
                "status":     "success",
                "page":       page,
                "limit":      limit,
                "total":      total,
                "totalPages": totalPages,
                "data":       response.FormatsAIResponse(responses),
        })</span>
}

// func cleanAIResponse(response string) string {
//         // Hapus tanda ** dan \n
//         response = strings.ReplaceAll(response, "**", "")
//         response = strings.ReplaceAll(response, "\\n", "\n")
//         return response
// }
</pre>
		
		<pre class="file" id="file25" style="display: none">package response

import (
        "capstone/entities"
        "net/http"

        "github.com/labstack/echo/v4"
)

type AIResponse struct {
        ID        int    `json:"id"`
        User      User   `json:"user"`
        Request   string `json:"request"`
        Response  string `json:"response"`
        CreatedAt string `json:"created_at"`
}

type User struct {
        ID    int    `json:"id"`
        Name  string `json:"name"`
        Email string `json:"email"`
        Phone string `json:"phone_number"`
        Photo string `json:"photo"`
}

type CustomerServiceResponse struct {
        User     User   `json:"user"`
        Request  string `json:"request"`
        Response string `json:"response"`
}

type SuccessResponseCS struct {
        Message string
        Data    CustomerServiceResponse
}

func FormatAIResponse(ai entities.AIResponse) AIResponse <span class="cov0" title="0">{
        return AIResponse{
                ID: ai.ID,
                User: User{
                        ID:    ai.UserID,
                        Name:  ai.User.Name,
                        Email: ai.User.Email,
                        Phone: ai.User.Phone,
                        Photo: ai.User.PhotoURL,
                },
                Request:   ai.Request,
                Response:  ai.Response,
                CreatedAt: ai.CreatedAt.Format("2006-01-02 15:04:05"),
        }
}</span>

func FormatsAIResponse(customers []entities.AIResponse) []AIResponse <span class="cov0" title="0">{
        var responses []AIResponse
        for _, customer := range customers </span><span class="cov0" title="0">{
                responses = append(responses, AIResponse{
                        ID: customer.ID,
                        User: User{
                                ID:    customer.UserID,
                                Name:  customer.User.Name,
                                Email: customer.User.Email,
                                Phone: customer.User.Phone,
                                Photo: customer.User.PhotoURL,
                        },
                        Request:  customer.Request,
                        Response: customer.Response,
                })
        }</span>
        <span class="cov0" title="0">return responses</span>
}

func SuccessResponse(c echo.Context, user entities.User, req string, res string) error <span class="cov0" title="0">{
        return c.JSON(http.StatusOK, SuccessResponseCS{
                Message: "AI response retrieved successfully",
                Data: CustomerServiceResponse{
                        User: User{
                                ID:    user.ID,
                                Name:  user.Name,
                                Email: user.Email,
                                Phone: user.Phone,
                                Photo: user.PhotoURL,
                        },
                        Request:  req,
                        Response: res,
                },
        })
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package feedbacks

import (
        "capstone/controllers/feedbacks/request"
        "capstone/controllers/feedbacks/response"
        "capstone/middlewares"
        "net/http"
        "strconv"

        "github.com/labstack/echo/v4"
)

func (cc *FeedbackController) ProvideFeedback(c echo.Context) error <span class="cov0" title="0">{
        // Validasi role admin
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        // Ambil admin ID dari JWT
        <span class="cov0" title="0">adminID, ok := c.Get("admin_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]string{"message": "Invalid admin token"})
        }</span>

        // Bind request
        <span class="cov0" title="0">req := request.FeedbackRequest{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request payload"})
        }</span>

        // Panggil service untuk memberikan feedback
        <span class="cov0" title="0">feedback, err := cc.feedbackService.ProvideFeedback(adminID, req.ComplaintID, req.Content)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": err.Error()})
        }</span>

        // Gunakan response untuk menampilkan data lengkap
        <span class="cov0" title="0">response := response.FromEntityFeedback(feedback)

        return c.JSON(http.StatusOK, map[string]interface{}{
                "message":  "Feedback provided successfully",
                "feedback": response,
        })</span>
}

func (cc *FeedbackController) UpdateFeedback(c echo.Context) error <span class="cov0" title="0">{
        // Validasi role admin
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        // Ambil feedback ID dari parameter
        <span class="cov0" title="0">feedbackID, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid feedback ID"})
        }</span>

        // Bind request
        <span class="cov0" title="0">req := request.FeedbackRequesContent{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request payload"})
        }</span>

        // Panggil service untuk memperbarui feedback
        <span class="cov0" title="0">updatedFeedback, err := cc.feedbackService.UpdateFeedback(feedbackID, req.Content)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": err.Error()})
        }</span>

        // Gunakan response untuk menampilkan data yang diperbarui
        <span class="cov0" title="0">response := response.FromEntityFeedback(updatedFeedback)

        return c.JSON(http.StatusOK, map[string]interface{}{
                "message":  "Feedback updated successfully",
                "feedback": response,
        })</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package response

import (
        "capstone/entities"
        "time"
)

type FeedbackResponse struct {
        ID        int       `json:"id"`
        Admin     Admin     `json:"admin"`
        User      User      `json:"user"`
        Complaint Complaint `json:"complaint"`
        Content   string    `json:"content"`
        CreatedAt time.Time `json:"created_at"`
}

type Admin struct {
        ID        int       `json:"id"`
        Email     string    `json:"email"`
        Role      string    `json:"role"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

type User struct {
        ID        int       `json:"id"`
        Name      string    `json:"name"`
        Email     string    `json:"email"`
        Phone     string    `json:"phone_number"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

type Complaint struct {
        ID              int              `json:"id"`
        Category        Category         `json:"category"`
        ComplaintNumber string           `json:"complaint_number"`
        Title           string           `json:"title"`
        Location        string           `json:"location"`
        Status          string           `json:"status"`
        Description     string           `json:"description"`
        Photos          []ComplaintPhoto `json:"photos"`
        CreatedAt       time.Time        `json:"created_at"`
        UpdatedAt       time.Time        `json:"updated_at"`
}

type Category struct {
        ID          int       `json:"id"`
        Name        string    `json:"name"`
        Description string    `json:"description"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

type ComplaintPhoto struct {
        ID        int       `json:"id"`
        PhotoURL  string    `json:"photo_url"`
        CreatedAt time.Time `json:"created_at"`
}

type FeedbackResponseWithResponse struct {
        ID        int       `json:"id"`
        Admin     Admin     `json:"admin"`
        User      User      `json:"user"`
        Complaint Complaint `json:"complaint"`
        Content   string    `json:"content"`
        Response  string    `json:"response"` // Tambahkan kolom ini
        CreatedAt time.Time `json:"created_at"`
}

func FromEntityFeedback(feedback entities.Feedback) FeedbackResponse <span class="cov0" title="0">{
        return FeedbackResponse{
                ID: feedback.ID,
                Admin: Admin{
                        ID:        feedback.Admin.ID,
                        Email:     feedback.Admin.Email,
                        Role:      feedback.Admin.Role,
                        CreatedAt: feedback.Admin.CreatedAt,
                        UpdatedAt: feedback.Admin.UpdatedAt,
                },
                User: User{
                        ID:        feedback.User.ID,
                        Name:      feedback.User.Name,
                        Email:     feedback.User.Email,
                        Phone:     feedback.User.Phone,
                        CreatedAt: feedback.User.CreatedAt,
                        UpdatedAt: feedback.User.UpdatedAt,
                },
                Complaint: Complaint{
                        ID:              feedback.Complaint.ID,
                        Category:        Category(feedback.Complaint.Category),
                        ComplaintNumber: feedback.Complaint.ComplaintNumber,
                        Title:           feedback.Complaint.Title,
                        Location:        feedback.Complaint.Location,
                        Status:          feedback.Complaint.Status,
                        Description:     feedback.Complaint.Description,
                        Photos:          FromEntityPhotos(feedback.Complaint.Photos),
                        CreatedAt:       feedback.Complaint.CreatedAt,
                        UpdatedAt:       feedback.Complaint.UpdatedAt,
                },
                Content:   feedback.Content,
                CreatedAt: feedback.CreatedAt,
        }
}</span>

func FromEntityPhotos(photos []entities.ComplaintPhoto) []ComplaintPhoto <span class="cov0" title="0">{
        var photoResponses []ComplaintPhoto
        for _, photo := range photos </span><span class="cov0" title="0">{
                photoResponses = append(photoResponses, ComplaintPhoto{
                        ID:        photo.ID,
                        PhotoURL:  photo.PhotoURL,
                        CreatedAt: photo.CreatedAt,
                })
        }</span>
        <span class="cov0" title="0">return photoResponses</span>
}

func FromEntitiesFeedbacks(feedbacks []entities.Feedback) []FeedbackResponse <span class="cov0" title="0">{
        var responses []FeedbackResponse
        for _, feedback := range feedbacks </span><span class="cov0" title="0">{
                responses = append(responses, FromEntityFeedback(feedback))
        }</span>
        <span class="cov0" title="0">return responses</span>
}

func FromEntityFeedbackWithResponse(feedback entities.Feedback) FeedbackResponseWithResponse <span class="cov0" title="0">{
        return FeedbackResponseWithResponse{
                ID: feedback.ID,
                Admin: Admin{
                        ID:        feedback.Admin.ID,
                        Email:     feedback.Admin.Email,
                        Role:      feedback.Admin.Role,
                        CreatedAt: feedback.Admin.CreatedAt,
                        UpdatedAt: feedback.Admin.UpdatedAt,
                },
                User: User{
                        ID:        feedback.User.ID,
                        Name:      feedback.User.Name,
                        Email:     feedback.User.Email,
                        Phone:     feedback.User.Phone,
                        CreatedAt: feedback.User.CreatedAt,
                        UpdatedAt: feedback.User.UpdatedAt,
                },
                Complaint: Complaint{
                        ID:              feedback.Complaint.ID,
                        Category:        Category(feedback.Complaint.Category),
                        ComplaintNumber: feedback.Complaint.ComplaintNumber,
                        Title:           feedback.Complaint.Title,
                        Location:        feedback.Complaint.Location,
                        Status:          feedback.Complaint.Status,
                        Description:     feedback.Complaint.Description,
                        Photos:          FromEntityPhotos(feedback.Complaint.Photos),
                        CreatedAt:       feedback.Complaint.CreatedAt,
                        UpdatedAt:       feedback.Complaint.UpdatedAt,
                },
                Content:   feedback.Content,
                Response:  feedback.Response, // Tampilkan responsenya
                CreatedAt: feedback.CreatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package feedbacks

import (
        "capstone/controllers/feedbacks/request"
        "capstone/controllers/feedbacks/response"
        feedback "capstone/services/feedbacks"
        "net/http"
        "strconv"

        "github.com/labstack/echo/v4"
)

type FeedbackController struct {
        feedbackService feedback.FeedbackServiceInterface
}

func NewFeedbackController(service feedback.FeedbackServiceInterface) *FeedbackController <span class="cov0" title="0">{
        return &amp;FeedbackController{feedbackService: service}
}</span>

func (fc *FeedbackController) GetFeedbackByComplaint(c echo.Context) error <span class="cov0" title="0">{
        // Ambil User ID dari middleware
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>

        // Ambil complaint_id dari parameter
        <span class="cov0" title="0">complaintID, err := strconv.Atoi(c.Param("complaint_id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "Invalid complaint ID",
                })
        }</span>

        // Ambil feedback melalui service
        <span class="cov0" title="0">feedback, err := fc.feedbackService.GetFeedbackByComplaint(complaintID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message":  "Feedback retrieved successfully",
                "feedback": response.FromEntityFeedback(feedback),
        })</span>
}

func (fc *FeedbackController) GetFeedbacksByUser(c echo.Context) error <span class="cov0" title="0">{
        // Ambil User ID dari middleware
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User not authorized",
                })
        }</span>

        // Ambil semua feedback dari service
        <span class="cov0" title="0">feedbacks, err := fc.feedbackService.GetFeedbacksByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]interface{}{
                        "message": "Failed to retrieve feedbacks",
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message":   "Feedbacks retrieved successfully",
                "feedbacks": response.FromEntitiesFeedbacks(feedbacks),
        })</span>
}

func (fc *FeedbackController) AddResponseToFeedback(c echo.Context) error <span class="cov0" title="0">{
        // Ambil User ID dari middleware
        userID, ok := c.Get("user_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, map[string]interface{}{
                        "message": "User tidak memiliki otorisasi",
                })
        }</span>

        // Ambil feedback ID dari parameter
        <span class="cov0" title="0">feedbackID, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "ID feedback tidak valid",
                })
        }</span>

        // Ambil data balasan dari body
        <span class="cov0" title="0">request := request.FeedbackRequesResponse{}
        if err := c.Bind(&amp;request); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": "Data Balasan Tidak Valid",
                })
        }</span>

        // Tambahkan balasan melalui service
        <span class="cov0" title="0">err = fc.feedbackService.AddResponseToFeedback(feedbackID, userID, request.Response)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]interface{}{
                        "message": err.Error(),
                })
        }</span>

        // Ambil feedback terbaru setelah balasan berhasil ditambahkan
        <span class="cov0" title="0">feedback, err := fc.feedbackService.GetFeedbackByID(feedbackID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]interface{}{
                        "message": "Gagal mengambil data feedback terbaru",
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message":  "Balasan Berhasil Ditambahkan",
                "feedback": response.FromEntityFeedbackWithResponse(feedback),
        })</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package news

import (
        "capstone/controllers/news/request"
        "capstone/controllers/news/response"
        "capstone/middlewares"
        "net/http"
        "strconv"

        "github.com/labstack/echo/v4"
)

func (nc *NewsController) GetAllNewsWithComments(c echo.Context) error <span class="cov0" title="0">{
        // Validasi role admin
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        // Ambil parameter pagination
        <span class="cov0" title="0">page, _ := strconv.Atoi(c.QueryParam("page"))
        limit, _ := strconv.Atoi(c.QueryParam("limit"))

        // Tetapkan nilai default jika page dan limit tidak diberikan
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        // Panggil service dengan pagination
        <span class="cov0" title="0">newsList, total, err := nc.newsService.GetAllNewsWithComments(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]string{
                        "message": "Failed to fetch news",
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Success",
                "news":    response.NewsFromEntities(newsList),
                "page":    page,
                "limit":   limit,
                "total":   total,
        })</span>
}

func (nc *NewsController) GetNewsDetailByAdmin(c echo.Context) error <span class="cov0" title="0">{
        // Validasi role admin
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        <span class="cov0" title="0">id := c.Param("id")

        news, err := nc.newsService.GetNewsByIDWithComments(id)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusNotFound, map[string]string{
                        "message": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Success",
                "news":    response.NewFromEntities(news),
        })</span>
}

func (nc *NewsController) AddNews(c echo.Context) error <span class="cov0" title="0">{
        // Validasi role admin
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        <span class="cov0" title="0">req := request.AddNewsRequest{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request payload"})
        }</span>

        // Konversi request ke entitas
        <span class="cov0" title="0">newsEntity := req.ToEntity()

        // Simpan berita baru dan dapatkan data lengkapnya
        news, err := nc.newsService.AddNews(newsEntity)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": err.Error()})
        }</span>

        // Kirimkan data berita lengkap dalam response
        <span class="cov0" title="0">return c.JSON(http.StatusCreated, map[string]interface{}{
                "message": "News created successfully",
                "data":    response.NewFromEntities(news),
        })</span>
}

func (nc *NewsController) UpdateNewsByAdmin(c echo.Context) error <span class="cov0" title="0">{
        // Validasi role admin
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        <span class="cov0" title="0">id := c.Param("id")

        req := request.AddNewsRequest{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": "Invalid request payload"})
        }</span>

        // Konversi request ke entitas
        <span class="cov0" title="0">newsEntity := req.ToEntity()

        // Panggil service untuk update berita
        updatedNews, err := nc.newsService.UpdateNewsByID(id, newsEntity)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{"message": err.Error()})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "News updated successfully",
                "data":    response.NewFromEntities(updatedNews),
        })</span>
}

func (nc *NewsController) DeleteMultipleNewsByAdmin(c echo.Context) error <span class="cov0" title="0">{
        // Validasi role admin
        role, err := middlewares.ExtractAdminRole(c)
        if err != nil || role != "admin" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusForbidden, map[string]string{"message": "Access denied"})
        }</span>

        <span class="cov0" title="0">var ids []int
        if err := c.Bind(&amp;ids); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{
                        "message": "Invalid request payload",
                })
        }</span>

        // Panggil service untuk menghapus berita
        <span class="cov0" title="0">err = nc.newsService.DeleteMultipleNews(ids)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{
                        "message": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]string{
                "message": "Selected news deleted successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package request

import (
        "capstone/entities"
        "time"
)

type AddNewsRequest struct {
        AdminID    int    `json:"admin_id"`
        CategoryID int    `json:"category_id"`
        Title      string `json:"title"`
        Content    string `json:"content"`
        PhotoURL   string `json:"photo_url"`
        Date       string `json:"date"`
}

func (req AddNewsRequest) ToEntity() entities.News <span class="cov0" title="0">{
        parsedDate, _ := time.Parse("2006-01-02", req.Date)
        return entities.News{
                AdminID:    req.AdminID,
                CategoryID: req.CategoryID,
                Title:      req.Title,
                Content:    req.Content,
                PhotoURL:   req.PhotoURL,
                Date:       parsedDate,
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package response

import (
        "capstone/entities"
        "time"
)

type NewsResponse struct {
        ID        int       `json:"id"`
        Admin     Admin     `json:"admin"`
        Category  Category  `json:"category"`
        Title     string    `json:"title"`
        Content   string    `json:"content"`
        PhotoURL  string    `json:"photo_url"`
        Date      time.Time `json:"date"`
        Comments  []Comment `json:"comments"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

type Comment struct {
        ID        int       `json:"id"`
        User      User      `json:"user"`
        Content   string    `json:"content"`
        CreatedAt time.Time `json:"created_at"`
}

type Admin struct {
        ID        int       `json:"id"`
        Email     string    `json:"email"`
        Role      string    `json:"role"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

type Category struct {
        ID          int       `json:"id"`
        Name        string    `json:"name"`
        Description string    `json:"description"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

type User struct {
        ID    int    `json:"id"`
        Name  string `json:"name"`
        Phone string `json:"phone_number"`
        Email string `json:"email"`
}

func NewFromEntities(news entities.News) NewsResponse <span class="cov0" title="0">{
        var comments []Comment
        for _, comment := range news.Comments </span><span class="cov0" title="0">{
                comments = append(comments, Comment{
                        ID:        comment.ID,
                        User:      User{ID: comment.User.ID, Name: comment.User.Name, Email: comment.User.Email},
                        Content:   comment.Content,
                        CreatedAt: comment.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return NewsResponse{
                ID:        news.ID,
                Admin:     Admin{ID: news.Admin.ID, Email: news.Admin.Email, Role: news.Admin.Role, CreatedAt: news.Admin.CreatedAt, UpdatedAt: news.Admin.UpdatedAt},
                Category:  Category{ID: news.Category.ID, Name: news.Category.Name, Description: news.Category.Description, CreatedAt: news.Category.CreatedAt, UpdatedAt: news.Category.UpdatedAt},
                Title:     news.Title,
                Content:   news.Content,
                PhotoURL:  news.PhotoURL,
                Date:      news.Date,
                Comments:  comments,
                CreatedAt: news.CreatedAt,
                UpdatedAt: news.UpdatedAt,
        }</span>
}

func NewsFromEntities(news []entities.News) []NewsResponse <span class="cov0" title="0">{
        var responses []NewsResponse
        for _, new := range news </span><span class="cov0" title="0">{
                responses = append(responses, NewFromEntities(new))
        }</span>
        <span class="cov0" title="0">return responses</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package news

import (
        "capstone/controllers/news/response"
        "capstone/services/news"
        "math"
        "net/http"
        "strconv"

        "github.com/labstack/echo/v4"
)

type NewsController struct {
        newsService news.NewsServiceInterface
}

func NewNewsController(service news.NewsServiceInterface) *NewsController <span class="cov0" title="0">{
        return &amp;NewsController{newsService: service}
}</span>

func (nc *NewsController) GetAllNews(c echo.Context) error <span class="cov0" title="0">{
        // Ambil parameter pagination
        page, err := strconv.Atoi(c.QueryParam("page"))
        if err != nil || page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1 // Default page
        }</span>

        <span class="cov0" title="0">limit, err := strconv.Atoi(c.QueryParam("limit"))
        if err != nil || limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 8 // Default limit
        }</span>

        // Panggil service dengan pagination
        <span class="cov0" title="0">news, total, err := nc.newsService.GetAllNews(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, map[string]interface{}{
                        "message": "Failed to retrieve news",
                })
        }</span>

        // Hitung total halaman
        <span class="cov0" title="0">totalPages := int(math.Ceil(float64(total) / float64(limit)))

        return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "News retrieved successfully",
                "news":    response.NewsFromEntities(news),
                "pagination": map[string]interface{}{
                        "page":       page,
                        "limit":      limit,
                        "total":      total,
                        "totalPages": totalPages,
                },
        })</span>
}

func (nc *NewsController) GetNewsByID(c echo.Context) error <span class="cov0" title="0">{
        // Ambil ID dari parameter URL
        id := c.Param("id")

        // Panggil service untuk mendapatkan detail berita berdasarkan ID
        news, err := nc.newsService.GetNewsByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusNotFound, map[string]interface{}{
                        "message": "News not found",
                })
        }</span>

        // Format response
        <span class="cov0" title="0">response := response.NewFromEntities(news)

        return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "News retrieved successfully",
                "news":    response,
        })</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package main

import (
        "capstone/config"
        "capstone/controllers/auth"
        "capstone/controllers/category"
        "capstone/controllers/comment"
        complaintsController "capstone/controllers/complaints"
        customerservice "capstone/controllers/customer_service"
        "capstone/controllers/feedbacks"
        "capstone/controllers/news"
        "capstone/middlewares"
        AuthRepositories "capstone/repositories/auth"
        categoryRepositories "capstone/repositories/category"
        commentRepositories "capstone/repositories/comment"
        complaintsRepo "capstone/repositories/complaints"
        csRepositories "capstone/repositories/customer_service"
        feedbackRepositories "capstone/repositories/feedbacks"
        newsRepositories "capstone/repositories/news"
        "capstone/routes"
        AuthServices "capstone/services/auth"
        categoryService "capstone/services/category"
        commentService "capstone/services/comment"
        complaintsService "capstone/services/complaints"
        csService "capstone/services/customer_service"
        feedbackService "capstone/services/feedbacks"
        newsService "capstone/services/news"
        "log"

        "github.com/joho/godotenv"
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
)

func main() <span class="cov0" title="0">{
        LoadEnv()
        // Connect to the database
        db, err := config.ConnectDatabase()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        // Jalankan migrasi database
        <span class="cov0" title="0">config.RunMigrations(db)

        // Membuat instance Echo
        e := echo.New()
        e.Use(middleware.CORS())
        e.Use(middleware.Logger())
        log.SetFlags(log.LstdFlags | log.Lshortfile)

        // Inisialisasi dependency untuk Auth
        jwtUser := middlewares.JwtUser{}
        repo := AuthRepositories.NewAuthRepository(db)
        service := AuthServices.NewAuthService(repo, jwtUser)
        authController := auth.NewAuthController(service)

        // Inisialisasi dependency untuk create complaint
        complaintRepo := complaintsRepo.NewComplaintRepo(db)
        complaintService := complaintsService.NewComplaintService(complaintRepo)
        complaintController := complaintsController.NewComplaintController(complaintService)

        // Inisialisasi dependency untuk Auth Admin
        jwtAdmin := middlewares.JwtAdmin{}
        repoAdmin := AuthRepositories.NewAdminRepository(db)
        serviceAdmin := AuthServices.NewAdminService(repoAdmin, jwtAdmin)
        authControllerAdmin := auth.NewAdminController(serviceAdmin)

        newsRepo := newsRepositories.NewNewsRepository(db)
        newsService := newsService.NewNewsService(newsRepo)
        newsController := news.NewNewsController(newsService)

        commentRepo := commentRepositories.NewCommentRepository(db)
        commentService := commentService.NewCommentService(commentRepo)
        commentController := comment.NewCommentController(commentService)

        feedbackRepo := feedbackRepositories.NewFeedbackRepository(db)
        feedbackService := feedbackService.NewFeedbackService(feedbackRepo)
        feedbackController := feedbacks.NewFeedbackController(feedbackService)

        customerServiceRepo := csRepositories.NewCustomerServiceseRepo(db)
        customerService := csService.NewCustomerService(customerServiceRepo)
        customerServiceController := customerservice.NewCustomerServiceController(customerService)

        categoryRepo := categoryRepositories.NewCategoryRepository(db)
        categoryService := categoryService.NewCategoryService(categoryRepo)
        categoryController := category.NewCategoryController(categoryService)

        // Mendaftarkan routes
        routeController := routes.RouteController{
                AuthController:            *authController,
                ComplaintController:       *complaintController,
                NewsController:            *newsController,
                CommentController:         *commentController,
                FeedbackController:        *feedbackController,
                CustomerServiceController: *customerServiceController,
                AuthAdminController:       *authControllerAdmin,
                CategoryController:        *categoryController,
        }
        routeController.RegisterRoutes(e)

        // Menjalankan server pada port 8000
        log.Println("Server starting on port 8000...")
        if err := e.Start(":8000"); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error starting server: %v", err)
        }</span>
}

func LoadEnv() <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error loading .env file")
        }</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package middlewares

import (
        "net/http"
        "os"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
        "golang.org/x/crypto/bcrypt"
)

type JwtInterface interface {
        GenerateJWT(userID int) (string, error)
}

type JwtUser struct {
}

type JwtCustomClaims struct {
        UserID int `json:"user_id"`
        jwt.RegisteredClaims
}

func (jwtUser JwtUser) GenerateJWT(userID int) (string, error) <span class="cov0" title="0">{
        claims := &amp;JwtCustomClaims{
                UserID: userID,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour * 72)),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        t, err := token.SignedString([]byte(os.Getenv("JWT_SECRET_KEY")))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return t, nil</span>
}

// HashPassword hashes a password using bcrypt
func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes), err
}</span>

// CheckPasswordHash compares a hashed password with a plaintext one
func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

func (jwtUser JwtUser) GetUserID(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                userToken, ok := c.Get("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusUnauthorized, map[string]string{"error": "Invalid token"})
                }</span>

                // Gunakan MapClaims dan pastikan token valid
                <span class="cov0" title="0">claims, ok := userToken.Claims.(jwt.MapClaims)
                if !ok || !userToken.Valid </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusUnauthorized, map[string]string{"error": "Invalid token claims"})
                }</span>

                // Ambil user_id dari claims dan simpan di context
                <span class="cov0" title="0">userID, ok := claims["user_id"].(float64)
                if !ok </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusUnauthorized, map[string]string{"error": "User ID not found in token"})
                }</span>
                <span class="cov0" title="0">c.Set("user_id", int(userID))

                return next(c)</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package middlewares

import (
        "net/http"
        "os"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
)

type JwtAdminInterface interface {
        GenerateJWT(adminID int, role string) (string, error)
}

type JwtAdmin struct {
}

type JwtAdminClaims struct {
        AdminID int    `json:"admin_id"`
        Role    string `json:"role"`
        jwt.RegisteredClaims
}

func (jwtAdmin JwtAdmin) GenerateJWT(adminID int, role string) (string, error) <span class="cov0" title="0">{
        claims := &amp;JwtAdminClaims{
                AdminID: adminID,
                Role:    role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)), // Token berlaku selama 24 jam
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        secretKey := os.Getenv("JWT_SECRET_KEY")
        return token.SignedString([]byte(secretKey))
}</span>

// Middleware untuk validasi JWT Admin
func (jwtAdmin JwtAdmin) JWTAdminMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                // Ambil token dari context
                userToken, ok := c.Get("user").(*jwt.Token)
                if !ok </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusUnauthorized, map[string]string{"error": "Invalid token"})
                }</span>

                // Validasi token claims
                <span class="cov0" title="0">claims, ok := userToken.Claims.(jwt.MapClaims)
                if !ok || !userToken.Valid </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusUnauthorized, map[string]string{"error": "Invalid token claims"})
                }</span>

                // Ambil admin_id dan role
                <span class="cov0" title="0">adminID, ok := claims["admin_id"].(float64)
                if !ok </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusUnauthorized, map[string]string{"error": "Admin ID not found in token"})
                }</span>
                <span class="cov0" title="0">role, ok := claims["role"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusUnauthorized, map[string]string{"error": "Role not found in token"})
                }</span>

                // Simpan admin_id dan role ke context
                <span class="cov0" title="0">c.Set("admin_id", int(adminID))
                c.Set("role", role)

                return next(c)</span>
        }
}

// ExtractAdminID extracts the admin ID from the context
func ExtractAdminID(c echo.Context) (int, error) <span class="cov0" title="0">{
        adminID, ok := c.Get("admin_id").(int)
        if !ok </span><span class="cov0" title="0">{
                return 0, echo.NewHTTPError(http.StatusUnauthorized, "Invalid admin ID")
        }</span>
        <span class="cov0" title="0">return adminID, nil</span>
}

// ExtractAdminRole extracts the admin role from the context
func ExtractAdminRole(c echo.Context) (string, error) <span class="cov0" title="0">{
        role, ok := c.Get("role").(string)
        if !ok </span><span class="cov0" title="0">{
                return "", echo.NewHTTPError(http.StatusUnauthorized, "Invalid role")
        }</span>
        <span class="cov0" title="0">return role, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package auth

import (
        "capstone/entities"
        "capstone/repositories/models"
        "capstone/utils"
        "errors"
        "time"

        "gorm.io/gorm"
)

func NewAuthRepository(db *gorm.DB) *AuthRepository <span class="cov0" title="0">{
        return &amp;AuthRepository{
                db: db,
        }
}</span>

type AuthRepositoryInterface interface {
        RegisterUser(entities.User) (entities.User, error)
        CheckEmailExists(email string) (bool, error)
        LoginUser(user entities.User) (entities.User, error)
        GetUserByEmail(email string) (entities.User, error)
        UpdateUser(user entities.User) error
        GetUserByID(userID int) (entities.User, error)
        UpdateUserProfile(user entities.User) error
}

type AuthRepository struct {
        db *gorm.DB
}

func (ar *AuthRepository) RegisterUser(user entities.User) (entities.User, error) <span class="cov0" title="0">{
        userDB := models.FromEntitiesUser(user)
        err := ar.db.Create(&amp;userDB)
        if err.Error != nil </span><span class="cov0" title="0">{
                return entities.User{}, err.Error
        }</span>
        <span class="cov0" title="0">return userDB.ToEntities(), nil</span>
}

func (ar *AuthRepository) LoginUser(user entities.User) (entities.User, error) <span class="cov0" title="0">{
        userDB := models.FromEntitiesUser(user)
        err := ar.db.First(&amp;userDB, "email = ?", userDB.Email)
        if err.Error != nil </span><span class="cov0" title="0">{
                return entities.User{}, errors.New(utils.CapitalizeErrorMessage(errors.New("email tidak ditemukan")))
        }</span>
        <span class="cov0" title="0">return userDB.ToEntities(), nil</span>
}

func (ar *AuthRepository) CheckEmailExists(email string) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := ar.db.Model(&amp;models.User{}).Where("email = ?", email).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (ar *AuthRepository) GetUserByEmail(email string) (entities.User, error) <span class="cov0" title="0">{
        var user models.User
        err := ar.db.First(&amp;user, "email = ?", email).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.User{}, err
        }</span>
        <span class="cov0" title="0">return user.ToEntities(), nil</span>
}

func (ar *AuthRepository) UpdateUser(user entities.User) error <span class="cov0" title="0">{
        userDB := models.FromEntitiesUser(user)

        // Siapkan data pembaruan
        updateData := map[string]interface{}{
                "name":       userDB.Name,
                "email":      userDB.Email,
                "password":   userDB.Password,
                "verified":   userDB.Verified,
                "otp":        userDB.OTP,
                "updated_at": time.Now(),
        }

        // Jika OTPExpiry kosong, atur ke NULL
        if userDB.OTPExpiry.IsZero() </span><span class="cov0" title="0">{
                updateData["otp_expiry"] = nil
        }</span> else<span class="cov0" title="0"> {
                updateData["otp_expiry"] = userDB.OTPExpiry
        }</span>

        // Lakukan pembaruan
        <span class="cov0" title="0">return ar.db.Model(&amp;models.User{}).Where("id = ?", userDB.ID).Updates(updateData).Error</span>
}

func (ar *AuthRepository) GetUserByID(userID int) (entities.User, error) <span class="cov0" title="0">{
        var user models.User
        err := ar.db.First(&amp;user, "id = ?", userID).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.User{}, err
        }</span>
        <span class="cov0" title="0">return user.ToEntities(), nil</span>
}

func (ar *AuthRepository) UpdateUserProfile(user entities.User) error <span class="cov0" title="0">{
        updateData := map[string]interface{}{}
        if user.Name != "" </span><span class="cov0" title="0">{
                updateData["name"] = user.Name
        }</span>
        <span class="cov0" title="0">if user.PhotoURL != "" </span><span class="cov0" title="0">{
                updateData["photo_url"] = user.PhotoURL
        }</span>
        <span class="cov0" title="0">if user.Password != "" </span><span class="cov0" title="0">{
                updateData["password"] = user.Password
        }</span>

        <span class="cov0" title="0">return ar.db.Model(&amp;models.User{}).Where("id = ?", user.ID).Updates(updateData).Error</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package auth

import (
        "capstone/entities"
        "capstone/repositories/models"
        "errors"
        "time"

        "gorm.io/gorm"
)

type AdminRepository struct {
        db *gorm.DB
}

// NewAdminRepository creates a new instance of AdminRepository
func NewAdminRepository(db *gorm.DB) *AdminRepository <span class="cov0" title="0">{
        return &amp;AdminRepository{db: db}
}</span>

// CreateAdmin creates a new admin in the database
func (repo *AdminRepository) CreateAdmin(admin entities.Admin) (entities.Admin, error) <span class="cov0" title="0">{
        modelAdmin := models.FromEntitiesAdmin(admin)
        if err := repo.db.Create(&amp;modelAdmin).Error; err != nil </span><span class="cov0" title="0">{
                return entities.Admin{}, err
        }</span>
        <span class="cov0" title="0">return modelAdmin.ToEntities(), nil</span>
}

// GetAllAdmin retrieves all admins from the database
func (repo *AdminRepository) GetAllAdmin() ([]entities.Admin, error) <span class="cov0" title="0">{
        var modelAdmins []models.Admin
        if err := repo.db.Find(&amp;modelAdmins).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var admins []entities.Admin
        for _, modelAdmin := range modelAdmins </span><span class="cov0" title="0">{
                admins = append(admins, modelAdmin.ToEntities())
        }</span>
        <span class="cov0" title="0">return admins, nil</span>
}

// GetAdminByID retrieves an admin by ID
func (repo *AdminRepository) GetAdminByID(id int) (entities.Admin, error) <span class="cov0" title="0">{
        var modelAdmin models.Admin
        if err := repo.db.First(&amp;modelAdmin, id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return entities.Admin{}, errors.New("admin not found")
                }</span>
                <span class="cov0" title="0">return entities.Admin{}, err</span>
        }
        <span class="cov0" title="0">return modelAdmin.ToEntities(), nil</span>
}

// UpdateAdmin updates an existing admin
func (repo *AdminRepository) UpdateAdmin(admin entities.Admin) (entities.Admin, error) <span class="cov0" title="0">{
        modelAdmin := models.FromEntitiesAdmin(admin)
        if err := repo.db.Model(&amp;modelAdmin).Updates(map[string]interface{}{
                "email":      modelAdmin.Email,
                "password":   modelAdmin.Password,
                "role":       modelAdmin.Role,
                "updated_at": time.Now(),
        }).Error; err != nil </span><span class="cov0" title="0">{
                return entities.Admin{}, err
        }</span>
        <span class="cov0" title="0">return modelAdmin.ToEntities(), nil</span>
}

// DeleteAdmin deletes an admin by ID
func (repo *AdminRepository) DeleteAdmin(id int) error <span class="cov0" title="0">{
        if err := repo.db.Delete(&amp;models.Admin{}, id).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (repo *AdminRepository) UpdateAdminProfile(admin entities.Admin) error <span class="cov0" title="0">{
        modelAdmin := models.FromEntitiesAdmin(admin)

        return repo.db.Model(&amp;models.Admin{}).Where("id = ?", admin.ID).Updates(map[string]interface{}{
                "email":      modelAdmin.Email,
                "password":   modelAdmin.Password,
                "photo":      modelAdmin.Photo,
                "updated_at": time.Now(),
        }).Error
}</span>

func (ar *AdminRepository) CheckEmailAdminExists(email string) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := ar.db.Model(&amp;models.Admin{}).Where("email = ?", email).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package category

import (
        "capstone/entities"
        "capstone/repositories/models"
        "context"

        "gorm.io/gorm"
)

// CategoryRepository defines the methods for accessing the Category data
type CategoryRepository interface {
        CreateCategory(ctx context.Context, category entities.Category) (entities.Category, error)
        GetCategoryByID(ctx context.Context, id int) (entities.Category, error)
        GetAllCategories(ctx context.Context) ([]entities.Category, error)
        UpdateCategory(ctx context.Context, category entities.Category) (entities.Category, error)
        DeleteCategory(ctx context.Context, id int) error
}

// categoryRepository is the concrete implementation of CategoryRepository
type categoryRepository struct {
        db *gorm.DB
}

// NewCategoryRepository creates a new instance of categoryRepository
func NewCategoryRepository(db *gorm.DB) CategoryRepository <span class="cov0" title="0">{
        return &amp;categoryRepository{db: db}
}</span>

// CreateCategory inserts a new category into the database
func (r *categoryRepository) CreateCategory(ctx context.Context, category entities.Category) (entities.Category, error) <span class="cov0" title="0">{
        model := models.FromEntitiesCategory(category)
        if err := r.db.WithContext(ctx).Create(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                return entities.Category{}, err
        }</span>
        <span class="cov0" title="0">return model.ToEntities(), nil</span>
}

// GetCategoryByID retrieves a category by its ID
func (r *categoryRepository) GetCategoryByID(ctx context.Context, id int) (entities.Category, error) <span class="cov0" title="0">{
        var model models.Category
        if err := r.db.WithContext(ctx).First(&amp;model, id).Error; err != nil </span><span class="cov0" title="0">{
                return entities.Category{}, err
        }</span>
        <span class="cov0" title="0">return model.ToEntities(), nil</span>
}

// GetAllCategories retrieves all categories from the database
func (r *categoryRepository) GetAllCategories(ctx context.Context) ([]entities.Category, error) <span class="cov0" title="0">{
        var modelsData []models.Category
        if err := r.db.WithContext(ctx).Find(&amp;modelsData).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var entitiesData []entities.Category
        for _, model := range modelsData </span><span class="cov0" title="0">{
                entitiesData = append(entitiesData, model.ToEntities())
        }</span>
        <span class="cov0" title="0">return entitiesData, nil</span>
}

// UpdateCategory updates an existing category in the database
func (r *categoryRepository) UpdateCategory(ctx context.Context, category entities.Category) (entities.Category, error) <span class="cov0" title="0">{
        model := models.FromEntitiesCategory(category)
        if err := r.db.WithContext(ctx).Save(&amp;model).Error; err != nil </span><span class="cov0" title="0">{
                return entities.Category{}, err
        }</span>
        <span class="cov0" title="0">return model.ToEntities(), nil</span>
}

// DeleteCategory removes a category from the database
func (r *categoryRepository) DeleteCategory(ctx context.Context, id int) error <span class="cov0" title="0">{
        if err := r.db.WithContext(ctx).Delete(&amp;models.Category{}, id).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file39" style="display: none">package comment

import (
        "capstone/entities"
        "capstone/repositories/models"
        "capstone/utils"
        "errors"

        "gorm.io/gorm"
)

type CommentRepositoryInterface interface {
        AddComment(comment entities.Comment) (entities.Comment, error)
        GetCommentsByUserID(userID int) ([]entities.Comment, error)
        CheckCategoryExists(id int) (bool, error)
        GetNewsByID(newsID int) (models.News, error)
        GetAllComments() ([]entities.Comment, error)
        GetCommentByID(commentID string) (entities.Comment, error)
}

type CommentRepository struct {
        db *gorm.DB
}

func NewCommentRepository(db *gorm.DB) *CommentRepository <span class="cov0" title="0">{
        return &amp;CommentRepository{db: db}
}</span>

func (cr *CommentRepository) AddComment(comment entities.Comment) (entities.Comment, error) <span class="cov0" title="0">{
        commentModel := models.FromEntitiesComment(comment)

        // Simpan komentar ke database
        if err := cr.db.Create(&amp;commentModel).Error; err != nil </span><span class="cov0" title="0">{
                return entities.Comment{}, errors.New(utils.CapitalizeErrorMessage(errors.New("gagal menambahkan komentar")))
        }</span>

        // Preload relasi user dan news
        <span class="cov0" title="0">if err := cr.db.Preload("User").Preload("News").First(&amp;commentModel, "id = ?", commentModel.ID).Error; err != nil </span><span class="cov0" title="0">{
                return entities.Comment{}, err
        }</span>

        <span class="cov0" title="0">return commentModel.ToEntities(), nil</span>
}

func (cr *CommentRepository) GetCommentsByUserID(userID int) ([]entities.Comment, error) <span class="cov0" title="0">{
        var comments []models.Comment

        // Query database untuk mengambil komentar berdasarkan user_id
        err := cr.db.Preload("User").Preload("News").Where("user_id = ?", userID).Order("created_at DESC").Find(&amp;comments).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Konversi model ke entitas
        <span class="cov0" title="0">var result []entities.Comment
        for _, comment := range comments </span><span class="cov0" title="0">{
                result = append(result, comment.ToEntities())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (ar *CommentRepository) CheckCategoryExists(categoryID int) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := ar.db.Model(&amp;models.Category{}).Where("id = ?", categoryID).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span> // True jika kategori ditemukan
}

func (ar *CommentRepository) GetNewsByID(newsID int) (models.News, error) <span class="cov0" title="0">{
        var news models.News
        err := ar.db.Preload("Category").First(&amp;news, "id = ?", newsID).Error
        if err != nil </span><span class="cov0" title="0">{
                return models.News{}, err
        }</span>
        <span class="cov0" title="0">return news, nil</span>
}

func (cr *CommentRepository) GetAllComments() ([]entities.Comment, error) <span class="cov0" title="0">{
        var comments []models.Comment

        // Query database untuk mengambil semua komentar
        err := cr.db.Preload("User").Preload("News").Order("created_at DESC").Find(&amp;comments).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Konversi model ke entitas
        <span class="cov0" title="0">var result []entities.Comment
        for _, comment := range comments </span><span class="cov0" title="0">{
                result = append(result, comment.ToEntities())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (cr *CommentRepository) GetCommentByID(commentID string) (entities.Comment, error) <span class="cov0" title="0">{
        var comment models.Comment

        // Query database untuk mengambil komentar berdasarkan ID
        err := cr.db.Preload("User").Preload("News").Where("id = ?", commentID).First(&amp;comment).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.Comment{}, err
        }</span>

        // Konversi model ke entitas
        <span class="cov0" title="0">return comment.ToEntities(), nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package complaints

import (
        "capstone/entities"
        "capstone/repositories/models"

        "gorm.io/gorm"
)

type ComplaintRepoInterface interface {
        CreateComplaint(c entities.Complaint) (entities.Complaint, error)
        AddComplaintPhotos(photos []entities.ComplaintPhoto) ([]entities.ComplaintPhoto, error)
        UserGetComplaintsByStatusAndCategory(userID int, status string, categoryID, page, limit int) ([]entities.Complaint, int64, error)
        IsComplaintNumberUnique(complaintNumber string) (bool, error)
        GetComplaintsByUserID(userID int) ([]entities.Complaint, error)
        GetComplaintByIDAndUser(id int, userID int) (entities.Complaint, error)
        GetComplaintsByStatusAndUser(status string, userID int) ([]entities.Complaint, error)
        GetAllComplaintsByUser(userID int) ([]entities.Complaint, error)
        CheckCategoryExists(categoryID int) (bool, error)
        GetComplaintsByCategoryAndUser(categoryID int, userID int) ([]entities.Complaint, error)
        GetComplaintByID(complaintID int) (models.Complaint, error)
        UpdateComplaintStatus(complaintID int, status string, reason string) error
        AdminGetComplaintsByStatusAndCategory(status string, categoryID, page, limit int) ([]entities.Complaint, int64, error)
        AdminGetComplaintDetailByID(complaintID int) (entities.Complaint, error)
        AdminGetComplaintByID(complaintID int) (entities.Complaint, error)
        AdminUpdateComplaint(complaintID int, updateData entities.Complaint) error
        DeleteComplaint(complaintID int) error
}

type ComplaintRepo struct {
        db *gorm.DB
}

func NewComplaintRepo(db *gorm.DB) *ComplaintRepo <span class="cov0" title="0">{
        return &amp;ComplaintRepo{db: db}
}</span>

func (cr *ComplaintRepo) CreateComplaint(c entities.Complaint) (entities.Complaint, error) <span class="cov0" title="0">{
        complaint := models.FromEntitiesComplaint(c)
        if err := cr.db.Create(&amp;complaint).Error; err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, err
        }</span>

        // Preload User dan Category setelah data disimpan
        <span class="cov0" title="0">err := cr.db.Preload("User").Preload("Category").First(&amp;complaint, "id = ?", complaint.ID).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, err
        }</span>

        <span class="cov0" title="0">return complaint.ToEntities(), nil</span>
}

func (cr *ComplaintRepo) UserGetComplaintsByStatusAndCategory(userID int, status string, categoryID, page, limit int) ([]entities.Complaint, int64, error) <span class="cov0" title="0">{
        var complaints []models.Complaint
        var total int64

        // Preload User, Category, dan Photos
        query := cr.db.Preload("User").Preload("Category").Preload("Photos").Preload("Feedbacks").
                Preload("Feedbacks.Admin").Where("user_id = ?", userID)

        // Tambahkan kondisi pencarian status jika ada
        if status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", status)
        }</span>

        // Tambahkan kondisi pencarian category_id jika ada
        <span class="cov0" title="0">if categoryID &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("category_id = ?", categoryID)
        }</span>

        // Hitung total data sebelum pagination
        <span class="cov0" title="0">if err := query.Model(&amp;models.Complaint{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Terapkan pagination jika limit &gt; 0
        <span class="cov0" title="0">if limit &gt; 0 </span><span class="cov0" title="0">{
                offset := (page - 1) * limit
                query = query.Offset(offset).Limit(limit)
        }</span>

        // Terapkan urutan descending berdasarkan waktu
        <span class="cov0" title="0">query = query.Order("created_at DESC")

        // Eksekusi query
        err := query.Find(&amp;complaints).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Konversi ke entities
        <span class="cov0" title="0">var result []entities.Complaint
        for _, complaint := range complaints </span><span class="cov0" title="0">{
                result = append(result, complaint.ToEntities())
        }</span>

        <span class="cov0" title="0">return result, total, nil</span>
}

func (cr *ComplaintRepo) AddComplaintPhotos(photos []entities.ComplaintPhoto) ([]entities.ComplaintPhoto, error) <span class="cov0" title="0">{
        var photoModels []models.ComplaintPhoto
        for _, photo := range photos </span><span class="cov0" title="0">{
                photoModels = append(photoModels, models.FromEntitiesComplaintPhoto(photo))
        }</span>

        // Simpan ke database
        <span class="cov0" title="0">if err := cr.db.Create(&amp;photoModels).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Konversi kembali ke slice entities.ComplaintPhoto
        <span class="cov0" title="0">var savedPhotos []entities.ComplaintPhoto
        for _, photoModel := range photoModels </span><span class="cov0" title="0">{
                savedPhotos = append(savedPhotos, photoModel.ToEntities())
        }</span>

        <span class="cov0" title="0">return savedPhotos, nil</span>
}

func (cr *ComplaintRepo) IsComplaintNumberUnique(complaintNumber string) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := cr.db.Model(&amp;models.Complaint{}).Where("complaint_number = ?", complaintNumber).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count == 0, nil</span>
}

func (cr *ComplaintRepo) GetComplaintsByUserID(userID int) ([]entities.Complaint, error) <span class="cov0" title="0">{
        var complaints []models.Complaint

        // Query database untuk mendapatkan keluhan berdasarkan user ID
        err := cr.db.Preload("User").
                Preload("Category").
                Preload("Photos").
                Preload("Feedbacks").
                Preload("Feedbacks.Admin").
                Where("user_id = ?", userID).
                Order("created_at DESC").
                Find(&amp;complaints).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Konversi hasil dari models ke entities
        <span class="cov0" title="0">var result []entities.Complaint
        for _, complaint := range complaints </span><span class="cov0" title="0">{
                result = append(result, complaint.ToEntities())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (cr *ComplaintRepo) GetComplaintByIDAndUser(complaintID, userID int) (entities.Complaint, error) <span class="cov0" title="0">{
        var complaint models.Complaint

        // Preload User, Category, Photos, dan Admin jika diperlukan
        err := cr.db.Preload("User").
                Preload("Category").
                Preload("Photos").
                Preload("Feedbacks").
                Preload("Feedbacks.Admin").
                Where("id = ? AND user_id = ?", complaintID, userID).
                Order("created_at DESC").
                First(&amp;complaint).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, err
        }</span>

        // Konversi dari model ke entitas
        <span class="cov0" title="0">return complaint.ToEntities(), nil</span>
}

func (cr *ComplaintRepo) GetComplaintsByStatusAndUser(status string, userID int) ([]entities.Complaint, error) <span class="cov0" title="0">{
        var complaints []models.Complaint

        // Query database untuk mendapatkan keluhan berdasarkan status dan user ID
        err := cr.db.Preload("User").Preload("Category").Preload("Photos").Preload("Feedbacks").Preload("Feedbacks.Admin").
                Where("status = ? AND user_id = ?", status, userID).Order("created_at DESC").Find(&amp;complaints).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Konversi hasil dari models ke entities
        <span class="cov0" title="0">var result []entities.Complaint
        for _, complaint := range complaints </span><span class="cov0" title="0">{
                result = append(result, complaint.ToEntities())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (cr *ComplaintRepo) GetAllComplaintsByUser(userID int) ([]entities.Complaint, error) <span class="cov0" title="0">{
        var complaints []models.Complaint

        // Query database untuk mendapatkan semua complaints milik user
        err := cr.db.Preload("User").
                Preload("Category").
                Preload("Photos").
                Preload("Feedbacks").
                Preload("Feedbacks.Admin").
                Where("user_id = ?", userID).
                Order("created_at DESC").Find(&amp;complaints).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Konversi hasil dari models ke entities
        <span class="cov0" title="0">var result []entities.Complaint
        for _, complaint := range complaints </span><span class="cov0" title="0">{
                result = append(result, complaint.ToEntities())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (cr *ComplaintRepo) CheckCategoryExists(categoryID int) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := cr.db.Model(&amp;models.Category{}).Where("id = ?", categoryID).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (cr *ComplaintRepo) GetComplaintsByCategoryAndUser(categoryID int, userID int) ([]entities.Complaint, error) <span class="cov0" title="0">{
        var complaints []models.Complaint

        // Query database untuk mendapatkan keluhan berdasarkan kategori dan user ID
        err := cr.db.Preload("User").Preload("Category").Preload("Photos").Preload("Feedbacks").Preload("Feedbacks.Admin").
                Where("category_id = ? AND user_id = ?", categoryID, userID).Order("created_at DESC").Find(&amp;complaints).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Konversi hasil dari models ke entities
        <span class="cov0" title="0">var result []entities.Complaint
        for _, complaint := range complaints </span><span class="cov0" title="0">{
                result = append(result, complaint.ToEntities())
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (cr *ComplaintRepo) GetComplaintByID(complaintID int) (models.Complaint, error) <span class="cov0" title="0">{
        var complaint models.Complaint
        err := cr.db.Preload("User").
                Preload("Category").
                Preload("Photos").
                Preload("Feedbacks").
                First(&amp;complaint, "id = ?", complaintID).Error
        if err != nil </span><span class="cov0" title="0">{
                return models.Complaint{}, err
        }</span>
        <span class="cov0" title="0">return complaint, nil</span>
}

func (cr *ComplaintRepo) UpdateComplaintStatus(complaintID int, status string, reason string) error <span class="cov0" title="0">{
        // Perbarui status dan simpan alasan pembatalan
        return cr.db.Model(&amp;models.Complaint{}).Where("id = ?", complaintID).Updates(map[string]interface{}{
                "status":     status,
                "reason":     reason,
                "updated_at": gorm.Expr("NOW()"),
        }).Error
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package complaints

import (
        "capstone/entities"
        "capstone/repositories/models"

        "gorm.io/gorm"
)

func (cr *ComplaintRepo) AdminGetComplaintsByStatusAndCategory(status string, categoryID, page, limit int) ([]entities.Complaint, int64, error) <span class="cov0" title="0">{
        var complaints []models.Complaint
        var total int64

        // Preload User, Category, dan Photos
        query := cr.db.Preload("User").Preload("Category").Preload("Photos")

        // Tambahkan kondisi pencarian status jika ada
        if status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", status)
        }</span>

        // Tambahkan kondisi pencarian category_id jika ada
        <span class="cov0" title="0">if categoryID &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("category_id = ?", categoryID)
        }</span>

        // Hitung total data sebelum pagination
        <span class="cov0" title="0">if err := query.Model(&amp;models.Complaint{}).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Terapkan pagination jika limit &gt; 0
        <span class="cov0" title="0">if limit &gt; 0 </span><span class="cov0" title="0">{
                offset := (page - 1) * limit
                query = query.Offset(offset).Limit(limit)
        }</span>

        // Terapkan urutan descending berdasarkan waktu
        <span class="cov0" title="0">query = query.Order("created_at DESC") // Tambahkan ini

        // Eksekusi query
        err := query.Find(&amp;complaints).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Konversi ke entities
        <span class="cov0" title="0">var result []entities.Complaint
        for _, complaint := range complaints </span><span class="cov0" title="0">{
                result = append(result, complaint.ToEntities())
        }</span>

        <span class="cov0" title="0">return result, total, nil</span>
}

func (cr *ComplaintRepo) AdminGetComplaintDetailByID(complaintID int) (entities.Complaint, error) <span class="cov0" title="0">{
        var complaint models.Complaint
        err := cr.db.Preload("User").
                Preload("Category").
                Preload("Photos").
                Preload("Feedbacks.Admin"). // Tambahkan preload untuk feedback dan admin
                Preload("Feedbacks").
                First(&amp;complaint, "id = ?", complaintID).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, err
        }</span>
        <span class="cov0" title="0">return complaint.ToEntitiesReason(), nil</span>
}

func (cr *ComplaintRepo) AdminGetComplaintByID(complaintID int) (entities.Complaint, error) <span class="cov0" title="0">{
        var complaint models.Complaint
        err := cr.db.Preload("User").Preload("Category").Preload("Admin").Preload("Photos").Preload("Feedbacks").Preload("Feedbacks.Admin").First(&amp;complaint, "id = ?", complaintID).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, err
        }</span>
        <span class="cov0" title="0">return complaint.ToEntities(), nil</span>
}

func (cr *ComplaintRepo) AdminUpdateComplaint(complaintID int, updateData entities.Complaint) error <span class="cov0" title="0">{
        // Bangun map untuk kolom yang akan diperbarui
        updateFields := map[string]interface{}{
                "category_id":      updateData.CategoryID,
                "title":            updateData.Title,
                "location":         updateData.Location,
                "status":           updateData.Status,
                "description":      updateData.Description,
                "complaint_number": updateData.ComplaintNumber,
                "admin_id":         updateData.AdminID, // Tambahkan AdminID
                "updated_at":       gorm.Expr("NOW()"),
        }

        // Perbarui data di database
        err := cr.db.Model(&amp;models.Complaint{}).Where("id = ?", complaintID).Updates(updateFields).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (cr *ComplaintRepo) DeleteComplaint(complaintID int) error <span class="cov0" title="0">{
        // Hapus data foto terkait di tabel complaint_photos
        if err := cr.db.Where("complaint_id = ?", complaintID).Delete(&amp;models.ComplaintPhoto{}).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Hapus data complaint
        <span class="cov0" title="0">if err := cr.db.Where("id = ?", complaintID).Delete(&amp;models.Complaint{}).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package customerservice

import (
        "capstone/entities"
        "capstone/repositories/models"
        "fmt"

        "gorm.io/gorm"
)

type AIResponseRepositoryInterface interface {
        SaveResponse(response entities.AIResponse) error
        GetUserByID(userID int) (entities.User, error)
        GetUserResponses(userID int, offset int, limit int) ([]entities.AIResponse, int, error)
}

func NewCustomerServiceseRepo(db *gorm.DB) *AIResponseRepository <span class="cov0" title="0">{
        return &amp;AIResponseRepository{db: db}
}</span>

type AIResponseRepository struct {
        db *gorm.DB
}

func (repo *AIResponseRepository) SaveResponse(response entities.AIResponse) error <span class="cov0" title="0">{
        if err := repo.db.Create(&amp;response).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save AI response: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (repo *AIResponseRepository) GetUserByID(userID int) (entities.User, error) <span class="cov0" title="0">{
        var user entities.User
        if err := repo.db.First(&amp;user, "id = ?", userID).Error; err != nil </span><span class="cov0" title="0">{
                return user, fmt.Errorf("failed to get user by ID: %w", err)
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (repo *AIResponseRepository) GetUserResponses(userID int, offset int, limit int) ([]entities.AIResponse, int, error) <span class="cov0" title="0">{
        var responses []models.AIResponse
        var total int64

        // Hitung total data untuk user tertentu
        if err := repo.db.Model(&amp;models.AIResponse{}).Where("user_id = ?", userID).Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count responses: %w", err)
        }</span>

        // Ambil data dengan batasan offset dan limit
        <span class="cov0" title="0">if err := repo.db.Preload("User").Where("user_id = ?", userID).Offset(offset).Limit(limit).Order("created_at DESC").Find(&amp;responses).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to retrieve responses: %w", err)
        }</span>

        // Konversi models ke entities
        <span class="cov0" title="0">var result []entities.AIResponse
        for _, response := range responses </span><span class="cov0" title="0">{
                result = append(result, response.ToEntities())
        }</span>

        <span class="cov0" title="0">return result, int(total), nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package feedbacks

import (
        "capstone/entities"
        "capstone/repositories/models"

        "gorm.io/gorm"
)

func (cr *FeedbackRepository) CreateFeedback(feedback *entities.Feedback) error <span class="cov0" title="0">{
        feedbackModel := models.Feedback{
                AdminID:     feedback.AdminID,
                UserID:      feedback.UserID,
                ComplaintID: feedback.ComplaintID,
                Content:     feedback.Content,
                CreatedAt:   feedback.CreatedAt,
        }

        // Simpan ke database
        if err := cr.db.Create(&amp;feedbackModel).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Perbarui ID feedback
        <span class="cov0" title="0">feedback.ID = feedbackModel.ID
        return nil</span>
}

func (cr *FeedbackRepository) CheckAdminExists(adminID int) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := cr.db.Model(&amp;models.Admin{}).Where("id = ?", adminID).Count(&amp;count).Error
        return count &gt; 0, err
}</span>

func (cr *FeedbackRepository) CheckUserExists(userID int) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := cr.db.Model(&amp;models.User{}).Where("id = ?", userID).Count(&amp;count).Error
        return count &gt; 0, err
}</span>

func (cr *FeedbackRepository) AdminUpdateComplaintStatus(complaintID int, newStatus string, adminID int) error <span class="cov0" title="0">{
        // Perbarui status dan admin ID di tabel complaints
        return cr.db.Model(&amp;models.Complaint{}).Where("id = ?", complaintID).Updates(map[string]interface{}{
                "status":     newStatus,
                "admin_id":   adminID,
                "updated_at": gorm.Expr("NOW()"),
        }).Error
}</span>

func (cr *FeedbackRepository) ComplaintHasFeedback(complaintID int) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := cr.db.Model(&amp;models.Feedback{}).Where("complaint_id = ?", complaintID).Count(&amp;count).Error
        return count &gt; 0, err
}</span>

func (cr *FeedbackRepository) UpdateFeedback(feedback entities.Feedback) error <span class="cov0" title="0">{
        feedbackModel := models.FromEntitiesFeedback(feedback)

        // Perbarui feedback di database
        err := cr.db.Model(&amp;models.Feedback{}).Where("id = ?", feedback.ID).Updates(map[string]interface{}{
                "content":    feedbackModel.Content, // Ubah kolom content
                "updated_at": gorm.Expr("NOW()"),
        }).Error

        return err
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package feedbacks

import (
        "capstone/entities"
        "capstone/repositories/models"
        "log"

        "gorm.io/gorm"
)

type FeedbackRepositoryInterface interface {
        GetComplaintByID(complaintID int) (entities.Complaint, error)
        GetFeedbackByComplaintID(complaintID int) (entities.Feedback, error)
        GetFeedbacksByUserID(userID int) ([]entities.Feedback, error)
        UpdateFeedbackResponse(feedbackID int, response string) error
        UpdateComplaintStatus(complaintID int, status string) error
        GetFeedbackByID(feedbackID int) (entities.Feedback, error)
        CreateFeedback(feedback *entities.Feedback) error
        CheckAdminExists(adminID int) (bool, error)
        CheckUserExists(userID int) (bool, error)
        AdminUpdateComplaintStatus(complaintID int, newStatus string, adminID int) error
        ComplaintHasFeedback(complaintID int) (bool, error)
        UpdateFeedback(feedback entities.Feedback) error
}

type FeedbackRepository struct {
        db *gorm.DB
}

func NewFeedbackRepository(db *gorm.DB) *FeedbackRepository <span class="cov0" title="0">{
        return &amp;FeedbackRepository{db: db}
}</span>

func (cr *FeedbackRepository) GetComplaintByID(complaintID int) (entities.Complaint, error) <span class="cov0" title="0">{
        var complaint models.Complaint
        err := cr.db.Preload("User").
                Preload("Category").
                Preload("Photos").
                Preload("Admin"). // Pastikan admin dimuat
                First(&amp;complaint, "id = ?", complaintID).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, err
        }</span>

        <span class="cov0" title="0">return complaint.ToEntities(), nil</span>
}

func (fr *FeedbackRepository) GetFeedbackByComplaintID(complaintID int) (entities.Feedback, error) <span class="cov0" title="0">{
        var feedback models.Feedback
        err := fr.db.Preload("Admin").
                Preload("User").
                Preload("Complaint.Category").
                Preload("Complaint.Photos").
                First(&amp;feedback, "complaint_id = ?", complaintID).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, err
        }</span>
        <span class="cov0" title="0">return feedback.ToEntities(), nil</span>
}

func (fr *FeedbackRepository) GetFeedbacksByUserID(userID int) ([]entities.Feedback, error) <span class="cov0" title="0">{
        var feedbacks []models.Feedback

        // Query database untuk mendapatkan feedback berdasarkan user_id
        err := fr.db.Preload("Admin").
                Preload("User").
                Preload("Complaint.Category").
                Preload("Complaint.Photos").
                Order("created_at DESC").
                Where("user_id = ?", userID).
                Find(&amp;feedbacks).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Konversi model feedback ke entities
        <span class="cov0" title="0">var result []entities.Feedback
        for _, feedback := range feedbacks </span><span class="cov0" title="0">{
                result = append(result, feedback.ToEntities())
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (fr *FeedbackRepository) UpdateFeedbackResponse(feedbackID int, response string) error <span class="cov0" title="0">{
        // Perbarui kolom response di tabel feedback
        return fr.db.Model(&amp;models.Feedback{}).Where("id = ?", feedbackID).Update("response", response).Error
}</span>

func (fr *FeedbackRepository) UpdateComplaintStatus(complaintID int, status string) error <span class="cov0" title="0">{
        // Perbarui status di tabel complaints
        return fr.db.Model(&amp;models.Complaint{}).Where("id = ?", complaintID).Update("status", status).Error
}</span>

func (cr *FeedbackRepository) GetFeedbackByID(feedbackID int) (entities.Feedback, error) <span class="cov0" title="0">{
        var feedback models.Feedback
        err := cr.db.Preload("Admin").
                Preload("User").
                Preload("Complaint").
                Preload("Complaint.Category"). // Preload relasi kategori
                Preload("Complaint.User").     // Preload user pada complaint
                Preload("Complaint.Photos").   // Preload foto pada complaint
                First(&amp;feedback, "id = ?", feedbackID).Error

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error fetching feedback: %v", err)
                return entities.Feedback{}, err
        }</span>

        <span class="cov0" title="0">return feedback.ToEntities(), nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package models

import (
        "capstone/entities"
        "time"
)

// Admin struct
type Admin struct {
        ID        int       `gorm:"primaryKey;autoIncrement"`
        Email     string    `gorm:"type:varchar(255);unique;not null"`
        Password  string    `gorm:"type:varchar(255);not null"`
        Role      string    `gorm:"type:enum('admin');not null;default:'admin'"`
        Photo     string    `gorm:"type:varchar(255)"`
        CreatedAt time.Time `gorm:"autoCreateTime"`
        UpdatedAt time.Time `gorm:"autoUpdateTime"`
}

// FromEntitiesAdmin maps entities.Admin to models.Admin
func FromEntitiesAdmin(admin entities.Admin) Admin <span class="cov0" title="0">{
        return Admin{
                ID:        admin.ID,
                Email:     admin.Email,
                Password:  admin.Password,
                Role:      admin.Role,
                Photo:     admin.Photo,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
}</span>

// ToEntities maps models.Admin to entities.Admin
func (admin Admin) ToEntities() entities.Admin <span class="cov0" title="0">{
        return entities.Admin{
                ID:        admin.ID,
                Email:     admin.Email,
                Password:  admin.Password,
                Role:      admin.Role,
                Photo:     admin.Photo,
                CreatedAt: admin.CreatedAt,
                UpdatedAt: admin.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package models

import (
        "capstone/entities"
        "time"
)

// AIResponse struct
type AIResponse struct {
        ID        uint      `gorm:"primaryKey;autoIncrement"`
        UserID    int       `gorm:"not null"`
        User      User      `gorm:"foreignKey:UserID"`
        Request   string    `gorm:"type:text;not null"`
        Response  string    `gorm:"type:text;not null"`
        CreatedAt time.Time `gorm:"autoCreateTime"`
}

func (r AIResponse) ToEntities() entities.AIResponse <span class="cov0" title="0">{
        return entities.AIResponse{
                ID:     int(r.ID),
                UserID: r.UserID,
                User: entities.User{
                        ID:       r.User.ID,
                        Name:     r.User.Name,
                        Email:    r.User.Email,
                        Phone:    r.User.Phone,
                        PhotoURL: r.User.PhotoURL,
                },
                Request:   r.Request,
                Response:  r.Response,
                CreatedAt: r.CreatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package models

import (
        "capstone/entities"
        "time"
)

// Category struct
type Category struct {
        ID          int       `gorm:"primaryKey;autoIncrement"`
        Name        string    `gorm:"type:varchar(255);not null"`
        Description string    `gorm:"type:text"`
        CreatedAt   time.Time `gorm:"autoCreateTime"`
        UpdatedAt   time.Time `gorm:"autoUpdateTime"`
}

func FromEntitiesCategory(c entities.Category) Category <span class="cov0" title="0">{
        return Category{
                ID:          c.ID,
                Name:        c.Name,
                Description: c.Description,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }
}</span>

func (c Category) ToEntities() entities.Category <span class="cov0" title="0">{
        return entities.Category{
                ID:          c.ID,
                Name:        c.Name,
                Description: c.Description,
                CreatedAt:   c.CreatedAt,
                UpdatedAt:   c.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package models

import (
        "capstone/entities"
        "time"
)

type Comment struct {
        ID        int       `gorm:"primaryKey;autoIncrement"`
        UserID    int       `gorm:"not null"`
        User      User      `gorm:"foreignKey:UserID"`
        NewsID    int       `gorm:"not null"`
        News      News      `gorm:"foreignKey:NewsID"`
        Content   string    `gorm:"type:text;not null"`
        CreatedAt time.Time `gorm:"autoCreateTime"`
}

func FromEntitiesComment(comment entities.Comment) Comment <span class="cov0" title="0">{
        return Comment{
                ID:        comment.ID,
                UserID:    comment.UserID,
                NewsID:    comment.NewsID,
                Content:   comment.Content,
                CreatedAt: time.Now(),
        }
}</span>

func (comment Comment) ToEntities() entities.Comment <span class="cov0" title="0">{
        return entities.Comment{
                ID:        comment.ID,
                UserID:    comment.UserID,
                User:      comment.User.ToEntities(),
                NewsID:    comment.NewsID,
                News:      comment.News.ToEntities(),
                Content:   comment.Content,
                CreatedAt: comment.CreatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package models

import (
        "capstone/entities"
        "time"
)

// Complaint struct
type Complaint struct {
        ID              int              `gorm:"primaryKey;autoIncrement"`
        AdminID         *int             `gorm:"admin_id"`
        Admin           Admin            `gorm:"foreignKey:AdminID"`
        UserID          int              `gorm:"not null"`
        User            User             `gorm:"foreignKey:UserID"`
        CategoryID      int              `gorm:"not null"`
        Category        Category         `gorm:"foreignKey:CategoryID"`
        ComplaintNumber string           `gorm:"type:varchar(255);unique"`
        Title           string           `gorm:"type:varchar(255);not null"`
        Location        string           `gorm:"type:varchar(255);not null"`
        Status          string           `gorm:"type:enum('proses', 'tanggapi', 'batal', 'selesai');default:'proses'"`
        Description     string           `gorm:"type:text;not null"`
        Photos          []ComplaintPhoto `gorm:"foreignKey:ComplaintID;constraint:OnDelete:CASCADE"`
        Reason          string           `gorm:"type:text"`
        Feedbacks       []Feedback       `gorm:"foreignKey:ComplaintID;constraint:OnDelete:CASCADE"`
        CreatedAt       time.Time        `gorm:"autoCreateTime"`
        UpdatedAt       time.Time        `gorm:"autoUpdateTime"`
}

func FromEntitiesComplaint(c entities.Complaint) Complaint <span class="cov0" title="0">{
        return Complaint{
                ID:              c.ID,
                UserID:          c.UserID,
                CategoryID:      c.CategoryID,
                ComplaintNumber: c.ComplaintNumber,
                Title:           c.Title,
                Location:        c.Location,
                Status:          c.Status,
                Description:     c.Description,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }
}</span>

func (c Complaint) ToEntities() entities.Complaint <span class="cov0" title="0">{
        var photos []entities.ComplaintPhoto
        for _, photo := range c.Photos </span><span class="cov0" title="0">{
                photos = append(photos, photo.ToEntities())
        }</span>

        <span class="cov0" title="0">var feedbacks []entities.Feedback
        for _, feedback := range c.Feedbacks </span><span class="cov0" title="0">{
                feedbacks = append(feedbacks, feedback.ToEntities())
        }</span>

        <span class="cov0" title="0">return entities.Complaint{
                ID:              c.ID,
                AdminID:         c.AdminID,
                Admin:           c.Admin.ToEntities(),
                UserID:          c.UserID,
                User:            c.User.ToEntities(),
                CategoryID:      c.CategoryID,
                Category:        c.Category.ToEntities(),
                ComplaintNumber: c.ComplaintNumber,
                Title:           c.Title,
                Location:        c.Location,
                Description:     c.Description,
                Status:          c.Status,
                Photos:          photos,
                Feedbacks:       feedbacks,
                CreatedAt:       c.CreatedAt,
                UpdatedAt:       c.UpdatedAt,
        }</span>
}

func (c Complaint) ToEntitiesReason() entities.Complaint <span class="cov0" title="0">{
        var photos []entities.ComplaintPhoto
        for _, photo := range c.Photos </span><span class="cov0" title="0">{
                photos = append(photos, photo.ToEntities())
        }</span>

        <span class="cov0" title="0">var feedbacks []entities.Feedback
        for _, feedback := range c.Feedbacks </span><span class="cov0" title="0">{
                feedbacks = append(feedbacks, feedback.ToEntities())
        }</span>

        <span class="cov0" title="0">return entities.Complaint{
                ID:              c.ID,
                AdminID:         c.AdminID,
                Admin:           c.Admin.ToEntities(),
                UserID:          c.UserID,
                User:            c.User.ToEntities(),
                CategoryID:      c.CategoryID,
                Category:        c.Category.ToEntities(),
                ComplaintNumber: c.ComplaintNumber,
                Title:           c.Title,
                Location:        c.Location,
                Description:     c.Description,
                Status:          c.Status,
                Photos:          photos,
                Feedbacks:       feedbacks,
                Reason:          c.Reason,
                CreatedAt:       c.CreatedAt,
                UpdatedAt:       c.UpdatedAt,
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package models

import (
        "capstone/entities"
        "time"
)

// Feedback struct
type Feedback struct {
        ID          int       `gorm:"primaryKey;autoIncrement"`
        AdminID     int       `gorm:"not null"`
        Admin       Admin     `gorm:"foreignKey:AdminID"`
        UserID      int       `gorm:"not null"`
        User        User      `gorm:"foreignKey:UserID"`
        ComplaintID int       `gorm:"not null"`
        Complaint   Complaint `gorm:"foreignKey:ComplaintID"`
        Content     string    `gorm:"type:text;not null"`
        Response    string    `gorm:"type:text"` // Tambahkan kolom ini
        CreatedAt   time.Time `gorm:"autoCreateTime"`
        UpdatedAt   time.Time `gorm:"autoUpdateTime"`
}

// FromEntitiesFeedback converts an entity feedback to a model feedback
func FromEntitiesFeedback(feedback entities.Feedback) Feedback <span class="cov0" title="0">{
        return Feedback{
                ID:          feedback.ID,
                AdminID:     feedback.Admin.ID,
                UserID:      feedback.User.ID,
                ComplaintID: feedback.Complaint.ID,
                Content:     feedback.Content,
                CreatedAt:   feedback.CreatedAt,
        }
}</span>

// ToEntities converts a model feedback to an entity feedback
func (feedback Feedback) ToEntities() entities.Feedback <span class="cov0" title="0">{
        return entities.Feedback{
                ID:      feedback.ID,
                AdminID: feedback.AdminID,
                Admin: entities.Admin{
                        ID:        feedback.Admin.ID,
                        Email:     feedback.Admin.Email,
                        Role:      feedback.Admin.Role,
                        CreatedAt: feedback.Admin.CreatedAt,
                        UpdatedAt: feedback.Admin.UpdatedAt,
                },
                UserID: feedback.UserID,
                User: entities.User{
                        ID:        feedback.User.ID,
                        Name:      feedback.User.Name,
                        Email:     feedback.User.Email,
                        Phone:     feedback.User.Phone,
                        CreatedAt: feedback.User.CreatedAt,
                        UpdatedAt: feedback.User.UpdatedAt,
                },
                ComplaintID: feedback.ComplaintID,
                Complaint: entities.Complaint{
                        ID:         feedback.Complaint.ID,
                        CategoryID: feedback.Complaint.CategoryID,
                        Category: entities.Category{
                                ID:          feedback.Complaint.Category.ID,
                                Name:        feedback.Complaint.Category.Name,
                                Description: feedback.Complaint.Category.Description,
                                CreatedAt:   feedback.Complaint.Category.CreatedAt,
                                UpdatedAt:   feedback.Complaint.Category.UpdatedAt,
                        },
                        ComplaintNumber: feedback.Complaint.ComplaintNumber,
                        Title:           feedback.Complaint.Title,
                        Location:        feedback.Complaint.Location,
                        Status:          feedback.Complaint.Status,
                        Description:     feedback.Complaint.Description,
                        Photos:          ToEntityPhotos(feedback.Complaint.Photos),
                        CreatedAt:       feedback.Complaint.CreatedAt,
                        UpdatedAt:       feedback.Complaint.UpdatedAt,
                },
                Content:   feedback.Content,
                Response:  feedback.Response,
                CreatedAt: feedback.CreatedAt,
        }
}</span>

// Helper function to convert ComplaintPhoto models to entities
func ToEntityPhotos(photos []ComplaintPhoto) []entities.ComplaintPhoto <span class="cov0" title="0">{
        var entityPhotos []entities.ComplaintPhoto
        for _, photo := range photos </span><span class="cov0" title="0">{
                entityPhotos = append(entityPhotos, photo.ToEntities())
        }</span>
        <span class="cov0" title="0">return entityPhotos</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package models

import (
        "capstone/entities"
        "time"
)

// News struct
type News struct {
        ID         int       `gorm:"primaryKey;autoIncrement"`
        AdminID    int       `gorm:"not null"`
        Admin      Admin     `gorm:"foreignKey:AdminID"`
        CategoryID int       `gorm:"not null"`
        Category   Category  `gorm:"foreignKey:CategoryID"`
        Title      string    `gorm:"type:varchar(255);not null"`
        Content    string    `gorm:"type:text;not null"`
        PhotoURL   string    `gorm:"type:varchar(255);not null"`
        Date       time.Time `gorm:"type:date;not null"`
        Comments   []Comment `gorm:"foreignKey:NewsID;constraint:OnDelete:CASCADE"`
        CreatedAt  time.Time `gorm:"autoCreateTime"`
        UpdatedAt  time.Time `gorm:"autoUpdateTime"`
}

func (news News) ToEntities() entities.News <span class="cov0" title="0">{
        return entities.News{
                ID:         news.ID,
                AdminID:    news.AdminID,
                Admin:      news.Admin.ToEntities(),
                CategoryID: news.CategoryID,
                Category:   news.Category.ToEntities(),
                Title:      news.Title,
                Content:    news.Content,
                PhotoURL:   news.PhotoURL,
                Date:       news.Date,
                CreatedAt:  news.CreatedAt,
                UpdatedAt:  news.UpdatedAt,
        }
}</span>

func FromEntitiesNews(news entities.News) News <span class="cov0" title="0">{
        return News{
                ID:         news.ID,
                AdminID:    news.AdminID,
                CategoryID: news.CategoryID,
                Title:      news.Title,
                Content:    news.Content,
                PhotoURL:   news.PhotoURL,
                Date:       news.Date,
                CreatedAt:  time.Now(),
                UpdatedAt:  time.Now(),
        }
}</span>

func (news News) ToEntitiesWithComment() entities.News <span class="cov0" title="0">{
        var comments []entities.Comment
        for _, comment := range news.Comments </span><span class="cov0" title="0">{
                comments = append(comments, comment.ToEntities())
        }</span>

        <span class="cov0" title="0">return entities.News{
                ID:        news.ID,
                Admin:     news.Admin.ToEntities(),
                Category:  news.Category.ToEntities(),
                Title:     news.Title,
                Content:   news.Content,
                PhotoURL:  news.PhotoURL,
                Date:      news.Date,
                Comments:  comments,
                CreatedAt: news.CreatedAt,
                UpdatedAt: news.UpdatedAt,
        }</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package models

import (
        "capstone/entities"
        "time"
)

type ComplaintPhoto struct {
        ID          int       `gorm:"primaryKey;autoIncrement"`
        ComplaintID int       `gorm:"not null"`
        PhotoURL    string    `gorm:"type:varchar(255);not null"`
        CreatedAt   time.Time `gorm:"autoCreateTime"`
}

func FromEntitiesComplaintPhoto(photo entities.ComplaintPhoto) ComplaintPhoto <span class="cov0" title="0">{
        return ComplaintPhoto{
                ID:          photo.ID,
                ComplaintID: photo.ComplaintID,
                PhotoURL:    photo.PhotoURL,
                CreatedAt:   time.Now(),
        }
}</span>

func (cp ComplaintPhoto) ToEntities() entities.ComplaintPhoto <span class="cov0" title="0">{
        return entities.ComplaintPhoto{
                ID:          cp.ID,
                ComplaintID: cp.ComplaintID,
                PhotoURL:    cp.PhotoURL,
                CreatedAt:   cp.CreatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package models

import (
        "capstone/entities"
        "time"
)

// User struct
type User struct {
        ID        int    `gorm:"primaryKey;autoIncrement"`
        Name      string `gorm:"type:varchar(255);not null"`
        Phone     string `gorm:"type:varchar(255);not null"`
        Email     string `gorm:"type:varchar(255);unique;not null"`
        Password  string `gorm:"type:varchar(255);not null"`
        PhotoURL  string `gorm:"type:varchar(255)"`
        Verified  bool   `gorm:"default:false"`
        OTP       string `gorm:"type:varchar(6)"`
        OTPExpiry time.Time
        CreatedAt time.Time `gorm:"autoCreateTime"`
        UpdatedAt time.Time `gorm:"autoUpdateTime"`
}

func FromEntitiesUser(user entities.User) User <span class="cov0" title="0">{
        return User{
                ID:        user.ID,
                Name:      user.Name,
                Phone:     user.Phone,
                Email:     user.Email,
                Password:  user.Password,
                PhotoURL:  user.PhotoURL,
                Verified:  user.Verified,
                OTP:       user.OTP,
                OTPExpiry: user.OTPExpiry,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
}</span>

func (user User) ToEntities() entities.User <span class="cov0" title="0">{
        return entities.User{
                ID:        user.ID,
                Name:      user.Name,
                Phone:     user.Phone,
                Email:     user.Email,
                Password:  user.Password,
                PhotoURL:  user.PhotoURL,
                Verified:  user.Verified,
                OTP:       user.OTP,
                OTPExpiry: user.OTPExpiry,
                CreatedAt: user.CreatedAt,
                UpdatedAt: user.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package news

import (
        "capstone/entities"
        "capstone/repositories/models"
        "errors"
)

func (nr *NewsRepository) GetAllNewsWithComments(page, limit int) ([]entities.News, int64, error) <span class="cov0" title="0">{
        var newsList []models.News
        var total int64

        // Hitung total data untuk pagination
        err := nr.db.Model(&amp;models.News{}).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Terapkan pagination dengan Offset dan Limit
        <span class="cov0" title="0">offset := (page - 1) * limit
        err = nr.db.Preload("Admin").
                Preload("Category").
                Preload("Comments.User").
                Order("created_at DESC").
                Offset(offset).Limit(limit).
                Find(&amp;newsList).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Konversi model ke entitas
        <span class="cov0" title="0">var result []entities.News
        for _, news := range newsList </span><span class="cov0" title="0">{
                newsEntity := news.ToEntitiesWithComment()
                result = append(result, newsEntity)
        }</span>

        <span class="cov0" title="0">return result, total, nil</span>
}

func (nr *NewsRepository) GetNewsByIDWithComments(id string) (entities.News, error) <span class="cov0" title="0">{
        var news models.News

        err := nr.db.Preload("Admin").
                Preload("Category").
                Preload("Comments.User").
                First(&amp;news, "id = ?", id).Error

        if err != nil </span><span class="cov0" title="0">{
                return entities.News{}, errors.New("news not found")
        }</span>

        <span class="cov0" title="0">return news.ToEntitiesWithComment(), nil</span>
}

func (nr *NewsRepository) IsCategoryValid(categoryID int) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := nr.db.Model(&amp;models.Category{}).Where("id = ?", categoryID).Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (nr *NewsRepository) CreateNews(news entities.News) (entities.News, error) <span class="cov0" title="0">{
        newsModel := models.FromEntitiesNews(news)

        // Simpan berita baru
        err := nr.db.Create(&amp;newsModel).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.News{}, err
        }</span>

        // Ambil berita yang baru saja disimpan, dengan memuat Admin dan Category terkait
        <span class="cov0" title="0">err = nr.db.Preload("Admin").Preload("Category").First(&amp;newsModel, "id = ?", newsModel.ID).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.News{}, err
        }</span>

        // Kembalikan data dalam bentuk entitas
        <span class="cov0" title="0">return newsModel.ToEntities(), nil</span>
}

func (nr *NewsRepository) UpdateNewsByID(id string, updatedNews entities.News) (entities.News, error) <span class="cov0" title="0">{
        var existingNews models.News

        // Cari berita berdasarkan ID
        err := nr.db.First(&amp;existingNews, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.News{}, errors.New("news not found")
        }</span>

        // Update data berita
        <span class="cov0" title="0">existingNews.Title = updatedNews.Title
        existingNews.Content = updatedNews.Content
        existingNews.PhotoURL = updatedNews.PhotoURL
        existingNews.CategoryID = updatedNews.CategoryID
        existingNews.Date = updatedNews.Date

        // Simpan perubahan
        err = nr.db.Save(&amp;existingNews).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.News{}, err
        }</span>

        // Preload Admin dan Category untuk response
        <span class="cov0" title="0">err = nr.db.Preload("Admin").Preload("Category").Preload("Comments.User").First(&amp;existingNews, "id = ?", existingNews.ID).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.News{}, err
        }</span>

        <span class="cov0" title="0">return existingNews.ToEntitiesWithComment(), nil</span>
}

func (nr *NewsRepository) ValidateNewsIDs(ids []int) ([]int, error) <span class="cov0" title="0">{
        var existingIDs []int
        err := nr.db.Model(&amp;models.News{}).Where("id IN ?", ids).Pluck("id", &amp;existingIDs).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return existingIDs, nil</span>
}

func (nr *NewsRepository) DeleteMultipleNews(ids []int) error <span class="cov0" title="0">{
        // Hapus berita berdasarkan id yang diterima
        err := nr.db.Where("id IN ?", ids).Delete(&amp;models.News{}).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package news

import (
        "capstone/entities"
        "capstone/repositories/models"
        "capstone/utils"
        "errors"

        "gorm.io/gorm"
)

type NewsRepositoryInterface interface {
        GetAllNews(page int, limit int) ([]entities.News, int64, error)
        GetNewsByID(id string) (entities.News, error)
        GetAllNewsWithComments(page, limit int) ([]entities.News, int64, error)
        GetNewsByIDWithComments(id string) (entities.News, error)
        IsCategoryValid(categoryID int) (bool, error)
        CreateNews(news entities.News) (entities.News, error)
        UpdateNewsByID(id string, updatedNews entities.News) (entities.News, error)
        DeleteMultipleNews(ids []int) error
        ValidateNewsIDs(ids []int) ([]int, error)
}

type NewsRepository struct {
        db *gorm.DB
}

func NewNewsRepository(db *gorm.DB) *NewsRepository <span class="cov0" title="0">{
        return &amp;NewsRepository{db: db}
}</span>

func (nr *NewsRepository) GetAllNews(page int, limit int) ([]entities.News, int64, error) <span class="cov0" title="0">{
        var news []models.News
        var total int64

        // Hitung total data
        err := nr.db.Model(&amp;models.News{}).Count(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Query berita dengan pagination
        <span class="cov0" title="0">offset := (page - 1) * limit
        err = nr.db.Preload("Admin").Preload("Category").Preload("Comments.User").
                Order("created_at DESC").
                Limit(limit).Offset(offset).
                Find(&amp;news).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Konversi model ke entitas
        <span class="cov0" title="0">var result []entities.News
        for _, n := range news </span><span class="cov0" title="0">{
                result = append(result, n.ToEntitiesWithComment())
        }</span>

        <span class="cov0" title="0">return result, total, nil</span>
}

func (nr *NewsRepository) GetNewsByID(id string) (entities.News, error) <span class="cov0" title="0">{
        var news models.News

        // Query berita berdasarkan ID dengan Preload admin dan category
        err := nr.db.Preload("Admin").Preload("Category").Preload("Comments.User").First(&amp;news, "id = ?", id).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.News{}, errors.New(utils.CapitalizeErrorMessage(errors.New("berita tidak ditemukan")))
        }</span>

        // Konversi model ke entitas
        <span class="cov0" title="0">return news.ToEntitiesWithComment(), nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package routes

import (
        "capstone/controllers/auth"
        "capstone/controllers/category"
        "capstone/controllers/comment"
        "capstone/controllers/complaints"
        customerservice "capstone/controllers/customer_service"
        feedback "capstone/controllers/feedbacks"
        "capstone/controllers/news"
        "capstone/middlewares"
        "os"

        echojwt "github.com/labstack/echo-jwt/v4"
        "github.com/labstack/echo/v4"
)

type RouteController struct {
        AuthController            auth.AuthController
        ComplaintController       complaints.ComplaintController
        NewsController            news.NewsController
        CommentController         comment.CommentController
        FeedbackController        feedback.FeedbackController
        jwtUser                   middlewares.JwtUser
        CustomerServiceController customerservice.CustomerServiceController
        AuthAdminController       auth.AdminController
        jwtAdmin                  middlewares.JwtAdmin
        CategoryController        category.CategoryController
}

// RegisterRoutes mengatur semua rute untuk aplikasi
func (rc RouteController) RegisterRoutes(e *echo.Echo) <span class="cov0" title="0">{
        // endpoint user
        e.POST("/register", rc.AuthController.RegisterController)
        e.POST("/login", rc.AuthController.LoginController)
        e.POST("/verify-otp", rc.AuthController.VerifyOTPController)

        eJwt := e.Group("")
        eJwt.Use(echojwt.JWT([]byte(os.Getenv("JWT_SECRET_KEY"))))

        // endpoint user profile
        eUserProfile := eJwt.Group("/user")
        eUserProfile.Use(rc.jwtUser.GetUserID)
        eUserProfile.GET("/profile", rc.AuthController.GetProfile)
        eUserProfile.PUT("/profile/name", rc.AuthController.UpdateName)         // Endpoint untuk memperbarui nama
        eUserProfile.PUT("/profile/photo", rc.AuthController.UpdatePhoto)       // Endpoint untuk memperbarui foto
        eUserProfile.PUT("/profile/password", rc.AuthController.UpdatePassword) // Endpoint untuk memperbarui password

        // endpoint complaints
        eComplaint := eJwt.Group("/complaint")
        eComplaint.Use(rc.jwtUser.GetUserID)
        eComplaint.POST("", rc.ComplaintController.CreateComplaintController)
        eComplaint.GET("", rc.ComplaintController.GetUserComplaintsByStatusAndCategory)
        // eComplaint.GET("", rc.ComplaintController.GetAllComplaintsByUser)
        eComplaint.GET("/:id", rc.ComplaintController.GetComplaintById)
        eComplaint.GET("/user", rc.ComplaintController.GetComplaintByUser)
        eComplaint.GET("/status/:status", rc.ComplaintController.GetComplaintsByStatus)
        eComplaint.GET("/category/:category_id", rc.ComplaintController.GetComplaintsByCategory)
        eComplaint.PUT("/:id/cancel", rc.ComplaintController.CancelComplaint)

        // endpoint news
        eNews := eJwt.Group("/news")
        eNews.GET("", rc.NewsController.GetAllNews)
        eNews.GET("/:id", rc.NewsController.GetNewsByID)

        // endpoint comment
        eComment := eJwt.Group("/comment")
        eComment.Use(rc.jwtUser.GetUserID)
        eComment.POST("", rc.CommentController.AddComment)
        eComment.GET("/user", rc.CommentController.GetCommentsByUser)
        eComment.GET("", rc.CommentController.GetAllComments)
        eComment.GET("/:id", rc.CommentController.GetCommentByID)

        // grup feedback
        eFeedback := eJwt.Group("/feedback")
        eFeedback.Use(rc.jwtUser.GetUserID)
        eFeedback.GET("/complaint/:complaint_id", rc.FeedbackController.GetFeedbackByComplaint)
        eFeedback.GET("", rc.FeedbackController.GetFeedbacksByUser)
        eFeedback.POST("/:id/response", rc.FeedbackController.AddResponseToFeedback)

        // grup customer service (ai)
        eCustomerService := eJwt.Group("/chatbot")
        eCustomerService.Use(rc.jwtUser.GetUserID)
        eCustomerService.POST("", rc.CustomerServiceController.ChatbotQueryController)
        eCustomerService.GET("/user-responses", rc.CustomerServiceController.GetUserResponses)

        // Grup Admin
        eAdmin := e.Group("/admin")
        eAdmin.POST("/register", rc.AuthAdminController.RegisterAdminHandler)
        eAdmin.POST("/login", rc.AuthAdminController.LoginAdminHandler)

        // Rute Admin yang dilindungi JWTAdminMiddleware
        eAdminJwt := eAdmin.Group("")
        eAdminJwt.Use(echojwt.JWT([]byte(os.Getenv("JWT_SECRET_KEY"))))
        eAdminJwt.Use(rc.jwtAdmin.JWTAdminMiddleware)
        eAdminJwt.GET("", rc.AuthAdminController.GetAllAdminsHandler)
        eAdminJwt.GET("/:id", rc.AuthAdminController.GetAdminByIDHandler)
        eAdminJwt.PUT("/:id", rc.AuthAdminController.UpdateAdminHandler)
        eAdminJwt.DELETE("/:id", rc.AuthAdminController.DeleteAdminHandler)
        eAdminJwt.GET("/profile", rc.AuthAdminController.GetAdminProfile)
        eAdminJwt.PUT("/profile", rc.AuthAdminController.UpdateAdminProfile)

        // Rute Admin untuk Kelola Complaints
        eAdminComplaints := eAdminJwt.Group("/complaint")
        eAdminComplaints.GET("/filter", rc.ComplaintController.GetComplaintsByStatusAndCategory)
        eAdminComplaints.GET("/:id", rc.ComplaintController.GetComplaintDetailByAdmin)
        eAdminComplaints.POST("/feedback", rc.FeedbackController.ProvideFeedback)
        eAdminComplaints.PUT("/:id", rc.ComplaintController.UpdateComplaintByAdmin)
        eAdminComplaints.DELETE("/:id", rc.ComplaintController.DeleteComplaintByAdmin)

        // Rute Admin untuk Kelola news
        eAdminNews := eAdminJwt.Group("/news")
        eAdminNews.GET("", rc.NewsController.GetAllNewsWithComments)
        eAdminNews.GET("/:id", rc.NewsController.GetNewsDetailByAdmin)
        eAdminNews.POST("", rc.NewsController.AddNews)
        eAdminNews.PUT("/:id", rc.NewsController.UpdateNewsByAdmin)
        eAdminNews.DELETE("/bulk-delete", rc.NewsController.DeleteMultipleNewsByAdmin)

        // Rute Admin untuk Kelola Feedback
        eAdminFeedback := eAdminJwt.Group("/feedback")
        eAdminFeedback.PUT("/:id", rc.FeedbackController.UpdateFeedback)

        // Rute Admin untuk Kelola Category
        eAdminCategory := eAdminJwt.Group("/category")
        eAdminCategory.GET("", rc.CategoryController.GetAllCategories)
        eAdminCategory.GET("/:id", rc.CategoryController.GetCategoryByID)
        eAdminCategory.POST("", rc.CategoryController.CreateCategory)
        eAdminCategory.PUT("/:id", rc.CategoryController.UpdateCategory)
        eAdminCategory.DELETE("/:id", rc.CategoryController.DeleteCategory)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package auth

import (
        "capstone/entities"
        "capstone/middlewares"
        repositories "capstone/repositories/auth"
        "capstone/utils"
        "errors"
        "fmt"
        "math/rand"
        "os"
        "time"

        "golang.org/x/crypto/bcrypt"
        "gopkg.in/gomail.v2"
)

// var sendOTPEmailFunc = sendOTPEmail

type AuthServiceInterface interface {
        RegisterUser(user entities.User) (entities.User, error)
        LoginUser(user entities.User) (entities.User, error)
        VerifyOTP(email, otp string) error
        GetUserByID(userID int) (entities.User, error)
        UpdateName(userID int, name string) (entities.User, error)
        UpdatePhoto(userID int, photoURL string) (entities.User, error)
        UpdatePassword(userID int, oldPassword, newPassword string) error
}

type AuthService struct {
        AuthRepository repositories.AuthRepositoryInterface
        jwtInterface   middlewares.JwtInterface
}

func NewAuthService(ar repositories.AuthRepositoryInterface, jwtInterface middlewares.JwtInterface) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                AuthRepository: ar,
                jwtInterface:   jwtInterface}
}</span>

func (as *AuthService) RegisterUser(user entities.User) (entities.User, error) <span class="cov8" title="1">{
        // Validasi email
        if user.Email == "" </span><span class="cov8" title="1">{
                return entities.User{}, errors.New(utils.CapitalizeErrorMessage(errors.New("email kosong")))
        }</span>

        // Validasi password
        <span class="cov8" title="1">if user.Password == "" </span><span class="cov8" title="1">{
                return entities.User{}, errors.New(utils.CapitalizeErrorMessage(errors.New("password kosong")))
        }</span>

        // Validasi name
        <span class="cov8" title="1">if user.Name == "" </span><span class="cov8" title="1">{
                return entities.User{}, errors.New(utils.CapitalizeErrorMessage(errors.New("nama kosong")))
        }</span>

        // Validasi phone
        <span class="cov8" title="1">if user.Phone == "" </span><span class="cov8" title="1">{
                return entities.User{}, errors.New(utils.CapitalizeErrorMessage(errors.New("nomor telepon kosong")))
        }</span>

        // Periksa apakah email sudah ada
        <span class="cov8" title="1">exists, err := as.AuthRepository.CheckEmailExists(user.Email)
        if err != nil </span><span class="cov0" title="0">{
                return entities.User{}, err
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                return entities.User{}, errors.New(utils.CapitalizeErrorMessage(errors.New("email sudah ada")))
        }</span>

        // Hash password
        <span class="cov0" title="0">hash, _ := HashPassword(user.Password)
        user.Password = hash

        // Generate OTP dan set waktu kedaluwarsa
        user.OTP = GenerateOTP()
        user.OTPExpiry = time.Now().Add(10 * time.Minute) // OTP berlaku 10 menit

        // Debug log untuk memastikan OTP terisi
        // fmt.Printf("Generated OTP: %s\n", user.OTP)

        // Buat user baru di database
        // fmt.Printf("Before saving to DB, OTP: %s\n", user.OTP)
        user, err = as.AuthRepository.RegisterUser(user)
        if err != nil </span><span class="cov0" title="0">{
                return entities.User{}, err
        }</span>
        // fmt.Printf("After saving to DB, OTP: %s\n", user.OTP)

        // Kirim OTP ke email
        <span class="cov0" title="0">err = sendOTPEmail(user)
        // err = sendOTPEmailFunc(user)
        if err != nil </span><span class="cov0" title="0">{
                return entities.User{}, fmt.Errorf("failed to send OTP email: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func sendOTPEmail(user entities.User) error <span class="cov0" title="0">{
        // Informasi pengirim
        from := os.Getenv("SMTP_EMAIL")
        password := os.Getenv("SMTP_PASSWORD")

        // Subjek dan isi email
        subject := "Terima Kasih Telah Mendaftar di Laporin"
        body := fmt.Sprintf(`
        &lt;!DOCTYPE html&gt;
        &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Selamat Datang di Laporin&lt;/title&gt;
        &lt;/head&gt;
        &lt;body style="font-family: Arial, sans-serif; line-height: 1.6;"&gt;
            &lt;h2&gt;Halo, %s&lt;/h2&gt;
            &lt;p&gt;Terima kasih telah mendaftar di aplikasi &lt;strong&gt;Laporin&lt;/strong&gt;. Untuk menyelesaikan proses pendaftaran, gunakan kode OTP berikut:&lt;/p&gt;
            &lt;h1 style="text-align: center; color: #4CAF50;"&gt;%s&lt;/h1&gt;
            &lt;p&gt;Kode ini hanya berlaku selama &lt;strong&gt;10 menit&lt;/strong&gt;. Jika Anda tidak meminta kode ini, silakan abaikan email ini.&lt;/p&gt;
            &lt;p&gt;Terima kasih,&lt;/p&gt;
            &lt;p&gt;&lt;strong&gt;Tim Laporin&lt;/strong&gt;&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    `, user.Name, user.OTP)

        // Konfigurasi SMTP Gmail
        smtpHost := "smtp.gmail.com"
        smtpPort := 587

        // Membuat pesan email
        m := gomail.NewMessage()
        m.SetHeader("From", from)
        m.SetHeader("To", user.Email)
        m.SetHeader("Subject", subject)
        m.SetBody("text/html", body)

        // Membuat koneksi ke server SMTP Gmail
        d := gomail.NewDialer(smtpHost, smtpPort, from, password)

        // Kirim email
        err := d.DialAndSend(m)
        if err != nil </span><span class="cov0" title="0">{
                // fmt.Printf("Failed to send email to %s: %s\n", user.Email, err.Error())
                return fmt.Errorf("failed to send email: %w", err)
        }</span>

        // fmt.Printf("OTP %s sent to email %s\n", user.OTP, user.Email)
        <span class="cov0" title="0">return nil</span>
}

func (as *AuthService) LoginUser(user entities.User) (entities.User, error) <span class="cov8" title="1">{
        if user.Email == "" </span><span class="cov8" title="1">{
                return entities.User{}, errors.New(utils.CapitalizeErrorMessage(errors.New("email kosong")))
        }</span> else<span class="cov8" title="1"> if user.Password == "" </span><span class="cov8" title="1">{
                return entities.User{}, errors.New(utils.CapitalizeErrorMessage(errors.New("password kosong")))
        }</span>

        <span class="cov8" title="1">oldPassword := user.Password

        // Cari pengguna berdasarkan email
        user, err := as.AuthRepository.LoginUser(user)
        if err != nil </span><span class="cov8" title="1">{
                return entities.User{}, err
        }</span>

        // Cek apakah email sudah diverifikasi
        <span class="cov8" title="1">if !user.Verified </span><span class="cov8" title="1">{
                return entities.User{}, errors.New(utils.CapitalizeErrorMessage(errors.New("email tidak terverifikasi")))
        }</span>

        // Cek kecocokan password
        <span class="cov8" title="1">match := CheckPasswordHash(oldPassword, user.Password)
        if !match </span><span class="cov8" title="1">{
                return entities.User{}, errors.New(utils.CapitalizeErrorMessage(errors.New("password salah")))
        }</span>

        // Generate token JWT
        <span class="cov8" title="1">token, err := as.jwtInterface.GenerateJWT(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.User{}, err
        }</span>

        <span class="cov8" title="1">user.Token = token
        return user, nil</span>
}

func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

func CheckPasswordHash(password, hash string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

func GenerateOTP() string <span class="cov8" title="1">{
        return fmt.Sprintf("%06d", rand.Intn(1000000)) // OTP 6 digit
}</span>

func (as *AuthService) VerifyOTP(email, otp string) error <span class="cov8" title="1">{
        user, err := as.AuthRepository.GetUserByEmail(email)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("pengguna tidak ditemukan")))
        }</span>

        // fmt.Printf("Verifying OTP %s for email %s. Stored OTP: %s\n", otp, email, user.OTP)

        // Periksa apakah OTP cocok
        <span class="cov8" title="1">if user.OTP != otp </span><span class="cov8" title="1">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("OTP tidak valid")))
        }</span>

        // Periksa apakah OTP sudah kedaluwarsa
        <span class="cov8" title="1">if time.Now().After(user.OTPExpiry) </span><span class="cov8" title="1">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("OTP sudah habis masa berlakunya")))
        }</span>

        <span class="cov8" title="1">if user.OTPExpiry.IsZero() </span><span class="cov0" title="0">{
                user.OTPExpiry = time.Now() // Atur ke nilai default yang valid jika diperlukan
        }</span>

        // Perbarui status verifikasi
        <span class="cov8" title="1">user.Verified = true
        user.OTP = ""                // Hapus OTP setelah verifikasi
        user.OTPExpiry = time.Time{} // Atur waktu kedaluwarsa ke nol (atau gunakan NULL)

        err = as.AuthRepository.UpdateUser(user)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("gagal memverifikasi email")))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (as *AuthService) GetUserByID(userID int) (entities.User, error) <span class="cov8" title="1">{
        user, err := as.AuthRepository.GetUserByID(userID)
        if err != nil </span><span class="cov8" title="1">{
                return entities.User{}, errors.New("user not found")
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

func (as *AuthService) UpdateName(userID int, name string) (entities.User, error) <span class="cov8" title="1">{
        user, err := as.AuthRepository.GetUserByID(userID)
        if err != nil </span><span class="cov8" title="1">{
                return entities.User{}, errors.New("user not found")
        }</span>

        <span class="cov8" title="1">user.Name = name
        err = as.AuthRepository.UpdateUser(user)
        if err != nil </span><span class="cov0" title="0">{
                return entities.User{}, errors.New("failed to update name")
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (as *AuthService) UpdatePhoto(userID int, photoURL string) (entities.User, error) <span class="cov8" title="1">{
        user, err := as.AuthRepository.GetUserByID(userID)
        if err != nil </span><span class="cov8" title="1">{
                return entities.User{}, errors.New("user not found")
        }</span>

        // Periksa apakah photoURL valid
        <span class="cov8" title="1">if photoURL == "" </span><span class="cov8" title="1">{
                return entities.User{}, errors.New("photo URL cannot be empty")
        }</span>

        <span class="cov8" title="1">user.PhotoURL = photoURL
        err = as.AuthRepository.UpdateUserProfile(user)
        if err != nil </span><span class="cov0" title="0">{
                return entities.User{}, errors.New("failed to update photo")
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (as *AuthService) UpdatePassword(userID int, oldPassword, newPassword string) error <span class="cov8" title="1">{
        user, err := as.AuthRepository.GetUserByID(userID)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("user not found")
        }</span>

        <span class="cov8" title="1">if !CheckPasswordHash(oldPassword, user.Password) </span><span class="cov8" title="1">{
                return errors.New("old password is incorrect")
        }</span>

        <span class="cov8" title="1">hashedPassword, _ := HashPassword(newPassword)
        user.Password = hashedPassword

        err = as.AuthRepository.UpdateUser(user)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("failed to update password")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package auth

import (
        "capstone/entities"
        "capstone/middlewares"
        repositories "capstone/repositories/auth"
        "capstone/utils"
        "errors"
        "fmt"

        "golang.org/x/crypto/bcrypt"
)

type AdminService struct {
        adminRepo    *repositories.AdminRepository
        jwtInterface middlewares.JwtAdminInterface
}

// NewAdminService creates a new instance of AdminService
func NewAdminService(adminRepo *repositories.AdminRepository, jwtInterface middlewares.JwtAdminInterface) *AdminService <span class="cov0" title="0">{
        return &amp;AdminService{adminRepo: adminRepo, jwtInterface: jwtInterface}
}</span>

// RegisterAdmin handles the registration of a new admin
func (service *AdminService) RegisterAdmin(admin entities.Admin) (entities.Admin, error) <span class="cov0" title="0">{
        // Periksa apakah email sudah ada
        exists, err := service.adminRepo.CheckEmailAdminExists(admin.Email)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Admin{}, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return entities.Admin{}, errors.New(utils.CapitalizeErrorMessage(errors.New("email sudah ada")))
        }</span>

        // Hash the password before saving it to the database
        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(admin.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Admin{}, err
        }</span>
        <span class="cov0" title="0">admin.Password = string(hashedPassword)

        // Save the admin to the database
        createdAdmin, err := service.adminRepo.CreateAdmin(admin)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Admin{}, err
        }</span>

        <span class="cov0" title="0">return createdAdmin, nil</span>
}

// AuthenticateAdmin validates admin credentials and returns a JWT token if valid
func (service *AdminService) AuthenticateAdmin(email, password string) (string, entities.Admin, error) <span class="cov0" title="0">{
        // Get all admins
        admins, err := service.adminRepo.GetAllAdmin()
        if err != nil </span><span class="cov0" title="0">{
                return "", entities.Admin{}, err
        }</span>

        // Find the admin by email
        <span class="cov0" title="0">var foundAdmin entities.Admin
        for _, admin := range admins </span><span class="cov0" title="0">{
                if admin.Email == email </span><span class="cov0" title="0">{
                        foundAdmin = admin
                        break</span>
                }
        }

        // If admin not found
        <span class="cov0" title="0">if foundAdmin.ID == 0 </span><span class="cov0" title="0">{
                return "", entities.Admin{}, errors.New("admin not found")
        }</span>

        // Check if the password is correct
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(foundAdmin.Password), []byte(password)); err != nil </span><span class="cov0" title="0">{
                return "", entities.Admin{}, errors.New("invalid password")
        }</span>

        // Generate JWT token
        <span class="cov0" title="0">token, err := service.jwtInterface.GenerateJWT(foundAdmin.ID, foundAdmin.Role)
        if err != nil </span><span class="cov0" title="0">{
                return "", entities.Admin{}, err
        }</span>

        <span class="cov0" title="0">return token, foundAdmin, nil</span>
}

// GetAllAdmins retrieves all admins
func (service *AdminService) GetAllAdmins() ([]entities.Admin, error) <span class="cov0" title="0">{
        return service.adminRepo.GetAllAdmin()
}</span>

// GetAdminByID retrieves an admin by ID
func (service *AdminService) GetAdminByID(id int) (entities.Admin, error) <span class="cov0" title="0">{
        return service.adminRepo.GetAdminByID(id)
}</span>

// UpdateAdmin handles the update of an admin's information
func (service *AdminService) UpdateAdmin(admin entities.Admin) (entities.Admin, error) <span class="cov0" title="0">{
        // Check if the admin exists
        existingAdmin, err := service.adminRepo.GetAdminByID(admin.ID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Admin{}, fmt.Errorf("admin not found")
        }</span>

        // Update only provided fields
        <span class="cov0" title="0">if admin.Email == "" </span><span class="cov0" title="0">{
                admin.Email = existingAdmin.Email
        }</span>
        <span class="cov0" title="0">if admin.Password != "" </span><span class="cov0" title="0">{
                hashedPassword, err := bcrypt.GenerateFromPassword([]byte(admin.Password), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.Admin{}, err
                }</span>
                <span class="cov0" title="0">admin.Password = string(hashedPassword)</span>
        } else<span class="cov0" title="0"> {
                admin.Password = existingAdmin.Password
        }</span>
        <span class="cov0" title="0">if admin.Role == "" </span><span class="cov0" title="0">{
                admin.Role = existingAdmin.Role
        }</span>

        <span class="cov0" title="0">return service.adminRepo.UpdateAdmin(admin)</span>
}

// DeleteAdmin handles the deletion of an admin by ID
func (service *AdminService) DeleteAdmin(id int) error <span class="cov0" title="0">{
        return service.adminRepo.DeleteAdmin(id)
}</span>

// ValidateAdminRole checks if an admin has the required role
func (service *AdminService) ValidateAdminRole(adminID int, requiredRole string) error <span class="cov0" title="0">{
        admin, err := service.adminRepo.GetAdminByID(adminID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if admin.Role != requiredRole </span><span class="cov0" title="0">{
                return errors.New("access denied: insufficient role")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (service *AdminService) UpdateAdminProfile(adminID int, email, password, photo string) (entities.Admin, error) <span class="cov0" title="0">{
        admin, err := service.adminRepo.GetAdminByID(adminID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Admin{}, err
        }</span>

        // Perbarui data jika ada perubahan
        <span class="cov0" title="0">if email != "" </span><span class="cov0" title="0">{
                admin.Email = email
        }</span>

        <span class="cov0" title="0">if password != "" </span><span class="cov0" title="0">{
                hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.Admin{}, errors.New("failed to hash password")
                }</span>
                <span class="cov0" title="0">admin.Password = string(hashedPassword)</span>
        }

        <span class="cov0" title="0">if photo != "" </span><span class="cov0" title="0">{
                admin.Photo = photo
        }</span>

        // Simpan perubahan ke database
        <span class="cov0" title="0">if err := service.adminRepo.UpdateAdminProfile(admin); err != nil </span><span class="cov0" title="0">{
                return entities.Admin{}, err
        }</span>

        <span class="cov0" title="0">return admin, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package category

import (
        "capstone/entities"
        "capstone/repositories/category"
        "capstone/utils"
        "context"
        "errors"
)

// CategoryService defines the methods for handling category business logic
type CategoryService interface {
        CreateCategory(ctx context.Context, category entities.Category) (entities.Category, error)
        GetCategoryByID(ctx context.Context, id int) (entities.Category, error)
        GetAllCategories(ctx context.Context) ([]entities.Category, error)
        UpdateCategory(ctx context.Context, category entities.Category) (entities.Category, error)
        DeleteCategory(ctx context.Context, id int) error
}

// categoryService is the concrete implementation of CategoryService
type categoryService struct {
        repo category.CategoryRepository
}

// NewCategoryService creates a new instance of categoryService
func NewCategoryService(repo category.CategoryRepository) CategoryService <span class="cov0" title="0">{
        return &amp;categoryService{repo: repo}
}</span>

// CreateCategory creates a new category after applying business logic
func (s *categoryService) CreateCategory(ctx context.Context, category entities.Category) (entities.Category, error) <span class="cov0" title="0">{
        createdCategory, err := s.repo.CreateCategory(ctx, category)
        if err != nil </span><span class="cov0" title="0">{
                // Capitalize the error message using utils
                return entities.Category{}, errors.New(utils.CapitalizeErrorMessage(err))
        }</span>
        <span class="cov0" title="0">return createdCategory, nil</span>
}

// GetCategoryByID retrieves a category by its ID
func (s *categoryService) GetCategoryByID(ctx context.Context, id int) (entities.Category, error) <span class="cov0" title="0">{
        category, err := s.repo.GetCategoryByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Category{}, errors.New(utils.CapitalizeErrorMessage(err))
        }</span>
        <span class="cov0" title="0">return category, nil</span>
}

// GetAllCategories retrieves all categories
func (s *categoryService) GetAllCategories(ctx context.Context) ([]entities.Category, error) <span class="cov0" title="0">{
        categories, err := s.repo.GetAllCategories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(utils.CapitalizeErrorMessage(err))
        }</span>
        <span class="cov0" title="0">return categories, nil</span>
}

// UpdateCategory updates a category after applying business logic
func (s *categoryService) UpdateCategory(ctx context.Context, category entities.Category) (entities.Category, error) <span class="cov0" title="0">{
        updatedCategory, err := s.repo.UpdateCategory(ctx, category)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Category{}, errors.New(utils.CapitalizeErrorMessage(err))
        }</span>
        <span class="cov0" title="0">return updatedCategory, nil</span>
}

// DeleteCategory deletes a category by its ID
func (s *categoryService) DeleteCategory(ctx context.Context, id int) error <span class="cov0" title="0">{
        err := s.repo.DeleteCategory(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(err))
        }</span>
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file60" style="display: none">package comment

import (
        "capstone/entities"
        "capstone/repositories/comment"
        "errors"
)

type CommentServiceInterface interface {
        AddComment(comment entities.Comment) (entities.Comment, error)
        GetCommentsByUserID(userID int) ([]entities.Comment, error)
        GetAllComments() ([]entities.Comment, error)
        GetCommentByID(commentID string) (entities.Comment, error)
}

type CommentService struct {
        commentRepo comment.CommentRepositoryInterface
}

func NewCommentService(repo comment.CommentRepositoryInterface) *CommentService <span class="cov0" title="0">{
        return &amp;CommentService{commentRepo: repo}
}</span>

func (cs *CommentService) AddComment(comment entities.Comment) (entities.Comment, error) <span class="cov0" title="0">{
        if comment.NewsID == 0 </span><span class="cov0" title="0">{
                return entities.Comment{}, errors.New("Berita tidak valid. Silakan pilih berita yang sesuai.")
        }</span>

        <span class="cov0" title="0">if comment.Content == "" </span><span class="cov0" title="0">{
                return entities.Comment{}, errors.New("Konten komentar tidak boleh kosong.")
        }</span>

        // Validasi berita
        <span class="cov0" title="0">news, err := cs.commentRepo.GetNewsByID(comment.NewsID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Comment{}, errors.New("Berita tidak ditemukan.")
        }</span>

        // Validasi kategori
        <span class="cov0" title="0">exists, err := cs.commentRepo.CheckCategoryExists(news.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Comment{}, errors.New("Terjadi kesalahan saat memeriksa kategori.")
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return entities.Comment{}, errors.New("Kategori berita tidak ditemukan.")
        }</span>

        <span class="cov0" title="0">return cs.commentRepo.AddComment(comment)</span>
}

func (cs CommentService) GetCommentsByUserID(userID int) ([]entities.Comment, error) <span class="cov0" title="0">{
        // Ambil data komentar berdasarkan user_id dari repository
        comments, err := cs.commentRepo.GetCommentsByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return comments, nil</span>
}

func (cs *CommentService) GetAllComments() ([]entities.Comment, error) <span class="cov0" title="0">{
        // Ambil semua komentar dari repository
        comments, err := cs.commentRepo.GetAllComments()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return comments, nil</span>
}

func (cs *CommentService) GetCommentByID(commentID string) (entities.Comment, error) <span class="cov0" title="0">{
        // Ambil detail komentar dari repository
        comment, err := cs.commentRepo.GetCommentByID(commentID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Comment{}, err
        }</span>
        <span class="cov0" title="0">return comment, nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package complaints

import (
        "capstone/entities"
        "capstone/repositories/complaints"
        "capstone/utils"
        "errors"
)

type ComplaintServiceInterface interface {
        CreateComplaint(c entities.Complaint, photoURLs []string) (entities.Complaint, []entities.ComplaintPhoto, error)
        GetUserComplaintsByStatusAndCategory(userID int, status string, categoryID, page, limit int) ([]entities.Complaint, int64, error)
        GetComplaintByIDAndUser(id int, userID int) (entities.Complaint, error)
        GetComplaintsByUserID(userID int) ([]entities.Complaint, error)
        GetComplaintsByStatusAndUser(status string, userID int) ([]entities.Complaint, error)
        GetAllComplaintsByUser(userID int) ([]entities.Complaint, error)
        ValidateCategoryID(categoryID int) error
        GetComplaintsByCategoryAndUser(categoryID int, userID int) ([]entities.Complaint, error)
        CancelComplaint(complaintID int, userID int, reason string) (entities.Complaint, error)
        GetComplaintsByStatusAndCategory(status string, categoryID, page, limit int) ([]entities.Complaint, int64, error)
        GetComplaintDetailByID(complaintID int) (entities.Complaint, error)
        // UpdateComplaintStatus(complaintID int, adminID int, newStatus string) error
        GetComplaintByID(complaintID int) (entities.Complaint, error)
        UpdateComplaintByAdmin(complaintID int, updateData entities.Complaint) error
        DeleteComplaintByAdmin(complaintID int) error
}

type ComplaintService struct {
        complaintRepo complaints.ComplaintRepoInterface
}

func NewComplaintService(cr complaints.ComplaintRepoInterface) *ComplaintService <span class="cov0" title="0">{
        return &amp;ComplaintService{complaintRepo: cr}
}</span>

func (cs *ComplaintService) CreateComplaint(c entities.Complaint, photoURLs []string) (entities.Complaint, []entities.ComplaintPhoto, error) <span class="cov0" title="0">{
        // Validasi data
        if c.Description == "" </span><span class="cov0" title="0">{
                return entities.Complaint{}, []entities.ComplaintPhoto{}, errors.New(utils.CapitalizeErrorMessage(errors.New("deskripsi diperlukan")))
        }</span>
        <span class="cov0" title="0">if c.CategoryID == 0 </span><span class="cov0" title="0">{
                return entities.Complaint{}, []entities.ComplaintPhoto{}, errors.New(utils.CapitalizeErrorMessage(errors.New("kategori diperlukan")))
        }</span>
        <span class="cov0" title="0">if c.ComplaintNumber == "" </span><span class="cov0" title="0">{
                return entities.Complaint{}, []entities.ComplaintPhoto{}, errors.New(utils.CapitalizeErrorMessage(errors.New("nomor pengaduan diperlukan")))
        }</span>
        <span class="cov0" title="0">if c.Title == "" </span><span class="cov0" title="0">{
                return entities.Complaint{}, []entities.ComplaintPhoto{}, errors.New(utils.CapitalizeErrorMessage(errors.New("judul pengaduan diperlukan")))
        }</span>
        <span class="cov0" title="0">if c.Location == "" </span><span class="cov0" title="0">{
                return entities.Complaint{}, []entities.ComplaintPhoto{}, errors.New(utils.CapitalizeErrorMessage(errors.New("lokasi pengaduan diperlukan")))
        }</span>

        // Cek keunikan nomor pengaduan
        <span class="cov0" title="0">isUnique, err := cs.complaintRepo.IsComplaintNumberUnique(c.ComplaintNumber)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, nil, errors.New(utils.CapitalizeErrorMessage(errors.New("gagal memvalidasi nomor pengaduan")))
        }</span>
        <span class="cov0" title="0">if !isUnique </span><span class="cov0" title="0">{
                return entities.Complaint{}, nil, errors.New(utils.CapitalizeErrorMessage(errors.New("nomor pengaduan harus unik")))
        }</span>

        // Simpan complaint
        <span class="cov0" title="0">complaint, err := cs.complaintRepo.CreateComplaint(c)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, []entities.ComplaintPhoto{}, err
        }</span>

        // Simpan foto jika ada
        <span class="cov0" title="0">var photos []entities.ComplaintPhoto
        for _, url := range photoURLs </span><span class="cov0" title="0">{
                photos = append(photos, entities.ComplaintPhoto{
                        ComplaintID: complaint.ID,
                        PhotoURL:    url,
                })
        }</span>

        // Simpan foto ke database
        <span class="cov0" title="0">if len(photos) &gt; 0 </span><span class="cov0" title="0">{
                photos, err = cs.complaintRepo.AddComplaintPhotos(photos)
                if err != nil </span><span class="cov0" title="0">{
                        return entities.Complaint{}, nil, err
                }</span>
        }

        <span class="cov0" title="0">return complaint, photos, nil</span>
}

func (cs *ComplaintService) GetUserComplaintsByStatusAndCategory(userID int, status string, categoryID, page, limit int) ([]entities.Complaint, int64, error) <span class="cov0" title="0">{
        // Validasi input status jika ada
        if status != "" </span><span class="cov0" title="0">{
                validStatuses := []string{"proses", "tanggapi", "batal", "selesai"}
                if !utils.StringInSlice(status, validStatuses) </span><span class="cov0" title="0">{
                        return nil, 0, errors.New(utils.CapitalizeErrorMessage(errors.New("status tidak valid")))
                }</span>
        }

        // Ambil data dari repository
        <span class="cov0" title="0">complaints, total, err := cs.complaintRepo.UserGetComplaintsByStatusAndCategory(userID, status, categoryID, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return complaints, total, nil</span>
}

func (cs *ComplaintService) GetComplaintByIDAndUser(id int, userID int) (entities.Complaint, error) <span class="cov0" title="0">{
        // Ambil data keluhan berdasarkan ID dan User ID
        return cs.complaintRepo.GetComplaintByIDAndUser(id, userID)
}</span>

func (cs *ComplaintService) GetComplaintsByUserID(userID int) ([]entities.Complaint, error) <span class="cov0" title="0">{
        // Ambil data keluhan berdasarkan user ID
        complaints, err := cs.complaintRepo.GetComplaintsByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return complaints, nil</span>
}

func (cs *ComplaintService) GetComplaintsByStatusAndUser(status string, userID int) ([]entities.Complaint, error) <span class="cov0" title="0">{
        // Ambil data keluhan berdasarkan status dan user ID
        complaints, err := cs.complaintRepo.GetComplaintsByStatusAndUser(status, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return complaints, nil</span>
}

func (cs *ComplaintService) GetAllComplaintsByUser(userID int) ([]entities.Complaint, error) <span class="cov0" title="0">{
        // Ambil data complaints dari repository
        complaints, err := cs.complaintRepo.GetAllComplaintsByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return complaints, nil</span>
}

func (cs *ComplaintService) ValidateCategoryID(categoryID int) error <span class="cov0" title="0">{
        exists, err := cs.complaintRepo.CheckCategoryExists(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("kategori tidak valid")))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cs ComplaintService) GetComplaintsByCategoryAndUser(categoryID int, userID int) ([]entities.Complaint, error) <span class="cov0" title="0">{
        // Ambil data keluhan berdasarkan kategori dan user ID
        complaints, err := cs.complaintRepo.GetComplaintsByCategoryAndUser(categoryID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return complaints, nil</span>
}

func (cs *ComplaintService) CancelComplaint(complaintID int, userID int, reason string) (entities.Complaint, error) <span class="cov0" title="0">{
        // Ambil complaint untuk validasi
        complaint, err := cs.complaintRepo.GetComplaintByID(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, errors.New(utils.CapitalizeErrorMessage(errors.New("pengaduan tidak ditemukan")))
        }</span>

        // Pastikan complaint milik user
        <span class="cov0" title="0">if complaint.UserID != userID </span><span class="cov0" title="0">{
                return entities.Complaint{}, errors.New(utils.CapitalizeErrorMessage(errors.New("anda tidak memiliki akses untuk membatalkan pengaduan ini")))
        }</span>

        // Pastikan complaint memiliki status "proses"
        <span class="cov0" title="0">if complaint.Status != "proses" </span><span class="cov0" title="0">{
                return entities.Complaint{}, errors.New(utils.CapitalizeErrorMessage(errors.New("hanya pengaduan dengan status 'proses' yang dapat dibatalkan")))
        }</span>

        // Pastikan alasan belum ada
        <span class="cov0" title="0">if complaint.Reason != "" </span><span class="cov0" title="0">{
                return entities.Complaint{}, errors.New(utils.CapitalizeErrorMessage(errors.New("pengaduan ini sudah memiliki alasan pembatalan")))
        }</span>

        // Perbarui status complaint menjadi "batal" dan simpan alasan
        <span class="cov0" title="0">err = cs.complaintRepo.UpdateComplaintStatus(complaintID, "batal", reason)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, errors.New(utils.CapitalizeErrorMessage(errors.New("gagal membatalkan pengaduan")))
        }</span>

        // Ambil pengaduan yang telah diperbarui
        <span class="cov0" title="0">updatedComplaint, err := cs.complaintRepo.GetComplaintByID(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, errors.New(utils.CapitalizeErrorMessage(errors.New("gagal mengambil pengaduan yang diperbarui")))
        }</span>

        <span class="cov0" title="0">return updatedComplaint.ToEntitiesReason(), nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package complaints

import (
        "capstone/entities"
        "capstone/utils"
        "errors"
)

func (cs *ComplaintService) GetComplaintsByStatusAndCategory(status string, categoryID, page, limit int) ([]entities.Complaint, int64, error) <span class="cov0" title="0">{
        // Validasi input status hanya jika tidak kosong
        if status != "" </span><span class="cov0" title="0">{
                validStatuses := []string{"proses", "tanggapi", "batal", "selesai"}
                if !utils.StringInSlice(status, validStatuses) </span><span class="cov0" title="0">{
                        return nil, 0, errors.New(utils.CapitalizeErrorMessage(errors.New("statusnya tidak valid")))
                }</span>
        }

        // Ambil data dari repository
        <span class="cov0" title="0">complaints, total, err := cs.complaintRepo.AdminGetComplaintsByStatusAndCategory(status, categoryID, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return complaints, total, nil</span>
}

func (cs *ComplaintService) GetComplaintDetailByID(complaintID int) (entities.Complaint, error) <span class="cov0" title="0">{
        // Ambil detail complaint dari repository
        complaint, err := cs.complaintRepo.AdminGetComplaintDetailByID(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Complaint{}, err
        }</span>

        <span class="cov0" title="0">return complaint, nil</span>
}

func (cs *ComplaintService) GetComplaintByID(complaintID int) (entities.Complaint, error) <span class="cov0" title="0">{
        return cs.complaintRepo.AdminGetComplaintByID(complaintID)
}</span>

func (cs *ComplaintService) UpdateComplaintByAdmin(complaintID int, updateData entities.Complaint) error <span class="cov0" title="0">{
        // Validasi status (jika diperlukan)
        if updateData.Status != "" </span><span class="cov0" title="0">{
                validStatuses := []string{"proses", "tanggapi", "batal", "selesai"}
                if !utils.StringInSlice(updateData.Status, validStatuses) </span><span class="cov0" title="0">{
                        return errors.New(utils.CapitalizeErrorMessage(errors.New("statusnya tidak valid")))
                }</span>
        }

        // Validasi apakah kategori ada (opsional)
        <span class="cov0" title="0">if updateData.CategoryID &gt; 0 </span><span class="cov0" title="0">{
                exists, err := cs.complaintRepo.CheckCategoryExists(updateData.CategoryID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return errors.New(utils.CapitalizeErrorMessage(errors.New("ID kategori tidak valid")))
                }</span>
        }

        // Perbarui data di repository
        <span class="cov0" title="0">err := cs.complaintRepo.AdminUpdateComplaint(complaintID, updateData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (cs *ComplaintService) DeleteComplaintByAdmin(complaintID int) error <span class="cov0" title="0">{
        // Periksa apakah complaint ada di database
        complaint, err := cs.complaintRepo.GetComplaintByID(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("pengaduan tidak ditemukan")))
        }</span>

        // Validasi jika diperlukan (opsional)
        <span class="cov0" title="0">if complaint.Status == "selesai" </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("pengaduan yang sudah selesai tidak dapat dihapus")))
        }</span>

        // Hapus complaint di repository
        <span class="cov0" title="0">err = cs.complaintRepo.DeleteComplaint(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("gagal menghapus keluhan")))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package customerservice

import (
        "capstone/entities"
        customerservice "capstone/repositories/customer_service"
        "time"
)

func NewCustomerService(ai customerservice.AIResponseRepositoryInterface) *CustomerService <span class="cov0" title="0">{
        return &amp;CustomerService{aiResponseRepo: ai}
}</span>

type CustomerServiceInterface interface {
        SaveAIResponse(userID int, request string, response string) error
        GetUserByID(userID int) (entities.User, error)
        GetUserResponses(userID int, page int, limit int) ([]entities.AIResponse, int, error)
}

type CustomerService struct {
        aiResponseRepo customerservice.AIResponseRepositoryInterface
}

func (service *CustomerService) SaveAIResponse(userID int, request string, response string) error <span class="cov0" title="0">{
        aiResponse := entities.AIResponse{
                UserID:    userID,
                Request:   request,
                Response:  response,
                CreatedAt: time.Now(),
        }

        // Simpan data ke repository
        return service.aiResponseRepo.SaveResponse(aiResponse)
}</span>

func (service *CustomerService) GetUserByID(userID int) (entities.User, error) <span class="cov0" title="0">{
        return service.aiResponseRepo.GetUserByID(userID)
}</span>

func (service *CustomerService) GetUserResponses(userID int, page int, limit int) ([]entities.AIResponse, int, error) <span class="cov0" title="0">{
        offset := (page - 1) * limit
        return service.aiResponseRepo.GetUserResponses(userID, offset, limit)
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package feedbacks

import (
        "capstone/entities"
        "capstone/utils"
        "errors"
        "time"
)

func (cs *FeedbackService) ProvideFeedback(adminID, complaintID int, content string) (entities.Feedback, error) <span class="cov0" title="0">{
        // Periksa apakah admin ID valid
        adminExists, err := cs.feedbackRepo.CheckAdminExists(adminID)
        if err != nil || !adminExists </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("admin tidak ditemukan")))
        }</span>

        // Periksa apakah complaint ID valid
        <span class="cov0" title="0">complaint, err := cs.feedbackRepo.GetComplaintByID(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("pengaduan tidak ditemukan")))
        }</span>

        // Periksa apakah complaint sudah memiliki feedback
        <span class="cov0" title="0">hasFeedback, err := cs.feedbackRepo.ComplaintHasFeedback(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("gagal memeriksa feedback pengaduan")))
        }</span>
        <span class="cov0" title="0">if hasFeedback </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("pengaduan sudah memiliki tanggapan")))
        }</span>

        // Pastikan user ID valid
        <span class="cov0" title="0">userExists, err := cs.feedbackRepo.CheckUserExists(complaint.UserID)
        if err != nil || !userExists </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("pengguna tidak ditemukan")))
        }</span>

        // Buat feedback entity
        <span class="cov0" title="0">feedback := entities.Feedback{
                AdminID:     adminID,
                ComplaintID: complaintID,
                UserID:      complaint.UserID,
                Content:     content,
                CreatedAt:   time.Now(),
        }

        // Simpan feedback di repository
        err = cs.feedbackRepo.CreateFeedback(&amp;feedback)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, err
        }</span>

        // Perbarui status complaint menjadi "tanggapi"
        <span class="cov0" title="0">err = cs.feedbackRepo.AdminUpdateComplaintStatus(complaintID, "tanggapi", adminID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("gagal memperbarui status pengaduan")))
        }</span>

        // Ambil feedback lengkap dengan relasi
        <span class="cov0" title="0">feedbackModel, err := cs.feedbackRepo.GetFeedbackByComplaintID(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("gagal mengambil masukan lengkap")))
        }</span>

        // Gabungkan feedback dan complaint yang diperbarui
        <span class="cov0" title="0">feedback = feedbackModel

        return feedback, nil</span>
}

func (cs *FeedbackService) UpdateFeedback(feedbackID int, content string) (entities.Feedback, error) <span class="cov0" title="0">{
        // Periksa apakah feedback ID valid
        feedback, err := cs.feedbackRepo.GetFeedbackByID(feedbackID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("tanggapan tidak ditemukan")))
        }</span>

        // Perbarui konten
        <span class="cov0" title="0">feedback.Content = content

        // Simpan perubahan ke database
        err = cs.feedbackRepo.UpdateFeedback(feedback)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("gagal memperbarui tanggapan")))
        }</span>

        // Ambil feedback yang diperbarui
        <span class="cov0" title="0">updatedFeedback, err := cs.feedbackRepo.GetFeedbackByID(feedbackID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("gagal mengambil tanggapan yang diperbarui")))
        }</span>

        <span class="cov0" title="0">return updatedFeedback, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package feedbacks

import (
        "capstone/entities"
        feedback "capstone/repositories/feedbacks"
        "capstone/utils"
        "errors"
)

type FeedbackServiceInterface interface {
        GetFeedbackByComplaint(complaintID int, userID int) (entities.Feedback, error)
        GetFeedbacksByUser(userID int) ([]entities.Feedback, error)
        AddResponseToFeedback(feedbackID int, userID int, response string) error
        GetFeedbackByID(feedbackID int, userID int) (entities.Feedback, error)
        ProvideFeedback(adminID, complaintID int, content string) (entities.Feedback, error)
        UpdateFeedback(feedbackID int, content string) (entities.Feedback, error)
}

type FeedbackService struct {
        feedbackRepo feedback.FeedbackRepositoryInterface
}

func NewFeedbackService(repo feedback.FeedbackRepositoryInterface) *FeedbackService <span class="cov0" title="0">{
        return &amp;FeedbackService{feedbackRepo: repo}
}</span>

func (fs *FeedbackService) GetFeedbackByComplaint(complaintID int, userID int) (entities.Feedback, error) <span class="cov0" title="0">{
        // Validasi apakah complaint dimiliki oleh user dan statusnya 'tanggapi'
        complaint, err := fs.feedbackRepo.GetComplaintByID(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("pengaduan tidak ditemukan")))
        }</span>

        <span class="cov0" title="0">if complaint.UserID != userID </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("tidak berwenang untuk melihat tanggapan ini")))
        }</span>

        <span class="cov0" title="0">if complaint.Status != "tanggapi" </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("tanggapan tidak tersedia untuk pengaduan ini")))
        }</span>

        // Ambil feedback
        <span class="cov0" title="0">feedback, err := fs.feedbackRepo.GetFeedbackByComplaintID(complaintID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("tanggapan tidak ditemukan")))
        }</span>

        <span class="cov0" title="0">return feedback, nil</span>
}

func (fs *FeedbackService) GetFeedbacksByUser(userID int) ([]entities.Feedback, error) <span class="cov0" title="0">{
        // Ambil semua feedback dari repository
        feedbacks, err := fs.feedbackRepo.GetFeedbacksByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return feedbacks, nil</span>
}

func (fs *FeedbackService) AddResponseToFeedback(feedbackID int, userID int, response string) error <span class="cov0" title="0">{
        // Ambil feedback untuk validasi
        feedback, err := fs.feedbackRepo.GetFeedbackByID(feedbackID)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("tanggapan tidak ditemukan")))
        }</span>

        // Pastikan feedback milik user
        <span class="cov0" title="0">if feedback.UserID != userID </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("anda tidak memiliki akses untuk memberikan balasan pada tanggapan ini")))
        }</span>

        // Pastikan feedback belum memiliki balasan
        <span class="cov0" title="0">if feedback.Response != "" </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("tanggapan ini sudah memiliki balasan")))
        }</span>

        // Pastikan status complaint
        <span class="cov0" title="0">if feedback.Complaint.Status != "tanggapi" </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("tanggapan tidak dapat diberikan komentar")))
        }</span>

        // Tambahkan balasan
        <span class="cov0" title="0">err = fs.feedbackRepo.UpdateFeedbackResponse(feedbackID, response)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("gagal memberikan balasan pada tanggapan")))
        }</span>

        // Perbarui status complaint menjadi "selesai"
        <span class="cov0" title="0">err = fs.feedbackRepo.UpdateComplaintStatus(feedback.ComplaintID, "selesai")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("gagal memperbarui status pengaduan")))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (fs *FeedbackService) GetFeedbackByID(feedbackID int, userID int) (entities.Feedback, error) <span class="cov0" title="0">{
        // Ambil feedback dari repository
        feedback, err := fs.feedbackRepo.GetFeedbackByID(feedbackID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("feedback tidak ditemukan")))
        }</span>

        // Pastikan feedback milik user
        <span class="cov0" title="0">if feedback.UserID != userID </span><span class="cov0" title="0">{
                return entities.Feedback{}, errors.New(utils.CapitalizeErrorMessage(errors.New("anda tidak memiliki akses untuk melihat feedback ini")))
        }</span>

        <span class="cov0" title="0">return feedback, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package news

import (
        "capstone/entities"
        "capstone/utils"
        "errors"
)

func (ns *NewsService) GetAllNewsWithComments(page, limit int) ([]entities.News, int64, error) <span class="cov0" title="0">{
        return ns.newsRepo.GetAllNewsWithComments(page, limit)
}</span>

func (ns *NewsService) GetNewsByIDWithComments(id string) (entities.News, error) <span class="cov0" title="0">{
        return ns.newsRepo.GetNewsByIDWithComments(id)
}</span>

func (ns *NewsService) AddNews(news entities.News) (entities.News, error) <span class="cov0" title="0">{
        // Validasi kategori
        isValid, err := ns.newsRepo.IsCategoryValid(news.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.News{}, err
        }</span>
        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                return entities.News{}, errors.New(utils.CapitalizeErrorMessage(errors.New("ID kategori tidak valid")))
        }</span>

        <span class="cov0" title="0">if news.AdminID == 0 </span><span class="cov0" title="0">{
                return entities.News{}, errors.New(utils.CapitalizeErrorMessage(errors.New("admin tidak ditemukan")))
        }</span>

        // Simpan berita baru
        <span class="cov0" title="0">newsEntity, err := ns.newsRepo.CreateNews(news)
        if err != nil </span><span class="cov0" title="0">{
                return entities.News{}, err
        }</span>

        <span class="cov0" title="0">return newsEntity, nil</span>
}

func (ns *NewsService) UpdateNewsByID(id string, updatedNews entities.News) (entities.News, error) <span class="cov0" title="0">{
        // Validasi kategori
        isValid, err := ns.newsRepo.IsCategoryValid(updatedNews.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                return entities.News{}, err
        }</span>
        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                return entities.News{}, errors.New(utils.CapitalizeErrorMessage(errors.New("ID kategori tidak benar")))
        }</span>

        // Panggil repository untuk update berita
        <span class="cov0" title="0">news, err := ns.newsRepo.UpdateNewsByID(id, updatedNews)
        if err != nil </span><span class="cov0" title="0">{
                return entities.News{}, err
        }</span>

        <span class="cov0" title="0">return news, nil</span>
}

func (ns *NewsService) DeleteMultipleNews(ids []int) error <span class="cov0" title="0">{
        // Validasi input
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("tidak ada berita yang dipilih untuk dihapus")))
        }</span>

        // Validasi apakah ID berita ada di database
        <span class="cov0" title="0">existingIDs, err := ns.newsRepo.ValidateNewsIDs(ids)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Cek jika ada ID yang tidak ditemukan
        <span class="cov0" title="0">if len(existingIDs) == 0 </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("berita tidak ditemukan")))
        }</span>
        <span class="cov0" title="0">if len(existingIDs) != len(ids) </span><span class="cov0" title="0">{
                return errors.New(utils.CapitalizeErrorMessage(errors.New("beberapa ID berita tidak ditemukan")))
        }</span>

        // Hapus berita yang valid
        <span class="cov0" title="0">err = ns.newsRepo.DeleteMultipleNews(existingIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package news

import (
        "capstone/entities"
        "capstone/repositories/news"
)

type NewsServiceInterface interface {
        GetAllNews(page int, limit int) ([]entities.News, int64, error)
        GetNewsByID(id string) (entities.News, error)
        GetAllNewsWithComments(page, limit int) ([]entities.News, int64, error)
        GetNewsByIDWithComments(id string) (entities.News, error)
        AddNews(news entities.News) (entities.News, error)
        UpdateNewsByID(id string, updatedNews entities.News) (entities.News, error)
        DeleteMultipleNews(ids []int) error
}

type NewsService struct {
        newsRepo news.NewsRepositoryInterface
}

func NewNewsService(repo news.NewsRepositoryInterface) *NewsService <span class="cov0" title="0">{
        return &amp;NewsService{newsRepo: repo}
}</span>

func (ns *NewsService) GetAllNews(page int, limit int) ([]entities.News, int64, error) <span class="cov0" title="0">{
        return ns.newsRepo.GetAllNews(page, limit)
}</span>

func (ns *NewsService) GetNewsByID(id string) (entities.News, error) <span class="cov0" title="0">{
        // Panggil repository untuk mendapatkan detail berita berdasarkan ID
        return ns.newsRepo.GetNewsByID(id)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package utils

import "strings"

// CapitalizeErrorMessage capitalizes the first letter of each word in an error message
func CapitalizeErrorMessage(err error) string <span class="cov8" title="1">{
        words := strings.Fields(err.Error()) // Pisahkan pesan error menjadi kata-kata
        for i, word := range words </span><span class="cov8" title="1">{
                words[i] = strings.ToUpper(string(word[0])) + word[1:]
        }</span>
        <span class="cov8" title="1">return strings.Join(words, " ")</span> // Gabungkan kembali menjadi satu pesan
}

// StringInSlice memeriksa apakah sebuah string ada di dalam slice
func StringInSlice(str string, list []string) bool <span class="cov0" title="0">{
        for _, v := range list </span><span class="cov0" title="0">{
                if v == str </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
